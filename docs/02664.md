# 什么可能出错:异步串行版本

> 原文:[https://hack aday . com/2016/06/22/what-could-go-error-asynchronous-serial-edition/](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/)

这是世界上最简单的事情——简单明了的串行数据。它是几乎所有嵌入式系统的后备通信协议，所以当芯片出现故障时，你真的想使用它。然而。当你最需要它的时候，你可能会发现，即使是异步串行也会让你花费几个小时的调试时间，并且让你的头皮增加几根白发。

在这篇文章中，我将涵盖大多数(所有？)异步串行协议可能出错的地方，以及如何诊断和调试这种最有用的数据传输方法。目标是让你充分意识到什么可能出错，当它出错时，你将在几分钟内系统地排除故障，而不是浪费几个小时。

## 基础工作

[![scope_44](../Images/fafab06db4b456cfe28eb36db8797b16.png)](https://hackaday.com/wp-content/uploads/2016/06/scope_44.png) 假设你有八位数据要以电子方式发送给我。如果我们之间有八根线(加上地)，你可以简单地拨动八个开关，在每根线上施加高电压或低电压。如果我在另一端有一些发光二极管，我只需读出哪些发光，我们就完成了。但是八根线是一大堆铜。因此，你决定只用一根线(加上地)一次发送一位。这就是串行通信的本质——通过随时间精确改变电线上的电压来串行发送比特。

听起来很容易，但现在我们要做出一些选择。你发送每一位有多快？亮起的 LED 代表 1 还是 0？我如何知道你的信息何时开始或停止？最后，如果我们都要向对方发送数据，我们需要两根电线。我们怎么知道我送哪一个，你送哪一个？这些选择中的每一个都是出错的地方，也是错误滋生的地方。

## RX/TX

最后一点，哪根线向哪个方向传输数据，令人惊讶地是一个常见的混淆来源，所以这是开始调试的好地方。

[![339538](../Images/d038c0d9ebcea44742100e501f083dd1.png)](https://hackaday.com/wp-content/uploads/2016/06/339538.png)

Source: [LE BLOG D’ESKIMON](http://eskimon.fr/102-arduino-301-generalites-voie-serie)

“RX”和“TX”分别代表“接收”和“发送”。大多数串行通信系统都有一个。通常设置是这样的:你会发现自己将一台设备上的“GND”连接到另一台设备上的“GND”。也许它们还会共用一根电源线，这样你就可以将其中一个的“VCC”连接到另一个的“VCC”上。然后，在卷轴上，你将一个设备上的“RX”连接到另一个设备上的“RX”。

这是第一个错误。两个设备都期望在它们的“RX”线上接收数据，所以它们都只是坐在那里等待，而两条“TX”线将结束彼此的通话。不，正确的做法是将一个设备的“RX”端口连接到另一个设备的“TX”端口，反之亦然。这是合乎逻辑的，对吗？为了帮助提醒你这一点，有时“TX”会被标记为“TXD”，其中“D”代表“设备”，这应该是为了提醒你，你是从这个设备的角度来看事情的。

不管你叫它什么，把一个叫“TX”的端口连接到一个叫“RX”的端口会给现代 CAD 程序带来麻烦，在现代 CAD 程序中，你是给网络命名，而不是给单个端口命名。连接两个设备的“GND”引脚的导线叫什么？“GND”是个好名字。连接“TX”和“RX”的线叫什么？连接“RX”和“TX”的那个怎么样？混乱占主导地位。

(请注意，SPI 有自己的问题，我们将在下次讨论，它将这些线路称为“主机输入、从机输出”和“主机输出、从机输入”。线路名称是一致的，如果你知道你在看哪个设备，你马上就能知道数据流向哪个方向。那好多了。)

所以第一个要问自己的调试问题是，你是否正确地穿过了信号线。即使你有，无论如何试着交换他们，因为即使你没有困惑，你也不能确定你上游的工程师没有。(我们已经看到它发生了。)

## 波特率

我们已经弄清楚了线路，那么你发送(和接收)数据的速度如何呢？这很重要，因为如果你在电线上看到一段时间的高电压，你需要知道这个“while”应该代表多少位。如果我给你四个零，你会看到一个恒定电压，时间是我给你两个零的两倍，但是我们必须在时基上达成一致，这样你就可以确定我不是只给你两个零，或者八个零。

每秒发送的位信号的数量被称为[波特率](https://en.wikipedia.org/wiki/Symbol_rate)，这是我们必须同意的。这意味着发送者和接收者都必须有相当准确的时钟，这样他们才能保持相同的时间。

留意波特率，如 2400、9600、38400 和 115200。如果你不知道你的目标设备的波特率，尝试一下也无妨。

### 自动窃听

这里有一个聪明的技巧，如果你事先不知道波特率，你或你的设备可以玩这个技巧。如果你接收到几个字节的数据，你可以跟踪电压在线路上保持恒定的时间长度，并找到最小的公分母。例如，如果您看到高电压持续 208 μs，然后低电压持续 104 μs，最后高电压持续 312 μs，则很可能位周期为 104 μs，相当于 9600 波特。如果更像 8 μs，那就是 115200 波特。解决了。

 [![9600 Baud](../Images/35c55f96eadf79529311b7e4a3c8aefe.png "scope_53")](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/scope_53/) 9600 Baud [![115,200 Baud](../Images/6aa4061765026b23144c4472c0b13472.png "scope_54")](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/scope_54/) 115,200 Baud

## 电压水平

你已经弄清楚了“RX”和“TX”线路，并且已经算出了波特率，所以你就可以很好地接收和发送数据了。现在的问题是如何解释它。换句话说，高压是 1 还是 0？

### RS-232 与 TTL 电压的关系

你不会认为这将是令人困惑的，但唉，历史与我们作对。过去最流行的串行标准 RS-232(T1)使用正电压和负电压(从 3 V 到 15 V 和从-3 V 到-15 V)分别表示 0 和 1。是的，没错。1 与负电压一起发送，较高的电压对应于 0。

切到现在，单边信令更常见。现在高电压(3.3 或 5 V)取 1，低电压(0 V)取 0。因此，如何将电压解释为数字这个问题的答案是:视情况而定。现代，但仍然是 RS-232 风格，信号将使用 0 V 和 5 V 作为 1 和 0，而 TTL 串行将正好相反。

 [![3.3 V TTL](../Images/300e223895282e5ddce71387e0e425b0.png "scope_43")](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/scope_43/) 3.3 V TTL [![5V "RS-232"-style](../Images/e348bd6c5fba55b0589451505fba9bf4.png "scope_42")](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/scope_42/) 5V “RS-232”-style

好消息是，可以用 LED(或者万用表，如果你喜欢的话)区分这两种情况。默认情况下，RS-232 和 TTL 系统都是从器件的“TX”端口发送 1 电平开始的。如果“TX”线路空闲高电平，你看到的是 TTL 系统。如果它闲置低，它更有可能使用 RS-232 极性。

### 逆变器电路

[![SimpleRS232](../Images/a6e61de515feaad9978d9601edbb97c6.png)](https://hackaday.com/wp-content/uploads/2016/06/simplers232.jpg) 如果你有一根 FTDI USB 转串行电缆，或者 CP2102 等克隆设备，你就 100%处于 TTL 串行状态。好消息。然而，如果你需要与另一个使用 RS-232 电平的设备接口，你就有一点工作要做了。

[这里的](http://picprojects.org.uk/projects/simpleSIO/ssio.htm)是一个 RS-232 到 TTL 的转换电路，适用于中等波特率，甚至可以为您处理电压电平转换。因此，您可以将 3.3 V 敏感的 ESP8266 电路连接到一台旧的-15 V 至 15 V 行式打印机，一切都会正常工作。这是你工具箱里的一个。它不是严格兼容的，因为它不会摆动到-12V(或其他任何电压)，但它的极性是正确的，并且可以与大多数设备一起工作。

如果你需要一些东西来与古老的 RS-232 设备接口，你可以选择一个芯片( [MAX-232 或等效的](https://www.sparkfun.com/tutorials/215))来为你产生更高的电压。事实上，如果你打开一个 RS-232 转换器，你有时会看到一个 USB-TTL 串行芯片与一个 MAX-232 配对。(便宜的只是把信号反相，并不比上面的双晶体管电路好。已经警告过你了。)

## 起始位、停止位、奇偶校验和字节序

你不能只把电压传到电线上。你必须知道信号何时开始和停止，以及要寻找什么数据。总的来说，这被称为[成帧](https://en.wikipedia.org/wiki/Data_frame)。大多数串行系统将使用相同的“8N1”帧，但当它们不使用时，值得了解一下。这三个字符分别对应于一次发送的位数、奇偶校验位和停止位数。让我们把它拆开。

每个数据包发送的数据位数是不言自明的，大多数串行协议一次发送一个字节的数据，所以这通常不是问题。但是在非常老的设备上，你有时会看到 7 位——毕竟 ASCII 只使用 7 位。反正每个包的位数就是“8N1”里的“8”。

现在让我们考虑一下“开始”和“停止”部分。因为发送设备的“TX”端口(和接收设备的“RX”)空闲高电平(对于 TTL)，所以您不能以 1 开始数据传输——您如何判断它是否已发送？因此，一个总是低电平的起始位开始数据包。

如果你发送一个字节，它会在很长一段时间内以高电平结束，很容易判断它在哪里结束。如果您发送两个字节，并且第二个字节以低起始位开始，那么您需要在第一个数据包的末尾发送至少一个高停止位。(当发送一个字节时，停止位融入 TX 线的背景高电平状态。)如果你一直在计数，那么发送 8 位至少需要 10 个信号:一个起始位和至少一个停止位。但是有些系统发送两个停止位，所以你必须再次指定。停止位数是“8N1”中的“1”。

下面是消息“* \ n”——星号和换行符(ASCII 10)——分别用一个和两个停止位发送。二进制的话，那就是`00101010 00001010`。停止位(分别为 1 和 2)出现在这两个字节之间，并且在每个字节之前还有一个起始位。看看你能否解决这个问题。

[![](../Images/66fef017ae190c9a5d2d0c680f3a334f.png)](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/scope_77/)

8N1

[![](../Images/0c114a0f7f1b0624147e8cebbd9f19c8.png)](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/scope_78/)

8N2

[![](../Images/170757626f1c8b6334124ddc7934c835.png)](https://hackaday.com/2016/06/22/what-could-go-wrong-asynchronous-serial-edition/scope_79/)

8O1

这就把我们带到了中间的“[奇偶校验位](https://en.wikipedia.org/wiki/Parity_bit)，它是高还是低取决于数据中 1 的数量是偶数还是奇数。并且选择将偶数编码为 1 还是将奇数编码为 1 是任意的。为了利用奇偶校验位作为错误检测机制，您需要知道哪个是哪个，因此它被指定为“N”表示无奇偶校验，或者“E”或“O”分别表示奇偶校验。当有奇偶校验位时，它被添加到数据之后，就在停止位之前。奇偶校验位使字节中`1`的个数分别为偶数或奇数，这就是错误检测方案。如果你使用偶数奇偶校验，并且你看到三个`1`，包括奇偶校验位，你知道有一个传输错误。

幸运的是，还有最后一个困惑你几乎不会看到:endianness 的问题。串行数字数据可以以最低有效位先发送，也可以以最高有效位发送。好消息是，TTL 和 RS-232 串行数据几乎总是最低有效位优先(或“小端”)，但其他一些串行协议，如互联网协议，首先发送其串行数据。坏消息是示波器在收到数据时从左到右显示数据，我们先写数字的最高有效位，所以当你阅读示波器镜头时，你必须颠倒你脑中的位模式。(换行字符中的这四个零应该有助于您确定方向。)

## 协议层:行尾

现在，你已经把所有的信号都理顺了。你会认为没有比这更糟的了。但是等等！由于串行通信随着时间的推移不断发展，因此有两种(可能三种)可能的方式来表示一行数据的结束。如果你在 Unix、Windows 和更老的 MacOS 机器上复制过文本文件，那么[行尾问题](https://en.wikipedia.org/wiki/Newline)是很熟悉的。每个人(自然地)使用不同的标准。这三种传统的混淆也入侵了嵌入式设备的世界。如果接收程序正在等待其中的一个，而你正在发送另一个，它不知道你什么时候完成，只会呆在那里。

简而言之，在另一个端点响应之前，您可能需要发送一个换行符(LF，ASCII 10)或一个回车符(CR，ASCII 13)或两者(CR+LF)。大多数终端程序会让你动态设置发送和接收，所以手动排除故障没什么大不了的。但是，如果您已经不确定您的微控制器代码在做什么，并且您看不到任何可以调整的地方，那么您可能不会想到您遇到了行尾问题。当然，没有什么可以阻止任何人在他们的协议中使用他们自己特定的行尾字符。叹气。

## 摘要

我们的串行线路故障排除指南到此结束，我已经涵盖了几乎所有可能的变量:使线路正确、选择合适的波特率、计算线路极性(TTL-或 RS-232-风格)、数据长度、停止位、奇偶校验和线路结束。如果你只是想从一个不透明的微控制器系统中获取一些数据，那么很多东西可能会一下子出错。然而，了解所有可能的因素会给你一个立足点——一个可以用来确保一切都按照你认为应该的方式运行的清单。

大多数时候，并没有那么糟糕。您将以一种标准波特率运行到 8N1。确保你的线是交叉的，并测试传输线上的电压以建立奇偶校验。然后，您可以使用不同的波特率。如果这不能救你，试试行尾。如果你仍然停滞不前，打开示波器，挖掘信号。

希望这对您有所帮助，调试愉快！接下来，我们将讨论 SPI。