# 代码工艺-嵌入 C++:隐藏的活动？

> 原文:[https://hack aday . com/2015/11/20/code-craft-embedding-c-hidden-activities/](https://hackaday.com/2015/11/20/code-craft-embedding-c-hidden-activities/)

什么是嵌入式系统？一般定义是专用于特定目的的计算机系统，即不是可用于不同任务的通用系统。这是一个非常宽泛的定义。我刚刚浏览了联合攻击战斗机的 C++编码指南。这是一个相当大的嵌入式系统，也是第一个允许 C++的国防部项目！当你使用自动取款机取钱时，你使用的是嵌入式系统。那些基本上是加固的个人电脑。在小的一端，我们有所有的物联网(IoT)设备。

之前关于嵌入 C++讨论[类](http://hackaday.com/2015/11/06/code-craft-embedding-c-classes/)、[虚函数](http://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/)、[和宏](http://hackaday.com/2015/10/16/code-craft-when-define-is-considered-harmful/)的文章获得了很多评论。我发现积极的和批评的评论都是有益的。更重要的是，批评性的评论为我指出了需要解决的问题，这也是我进入本文主题的原因。所以谢谢大家。

让我们来看看嵌入式系统什么时候应该或者不应该使用 C++，仔细看看这种说法，即可能有隐藏的活动会扰乱您精心计划的代码执行。

# 嵌入式开发板的局限性

嵌入式系统通常被认为资源有限，例如内存、处理能力。实时约束是另一个经常被提出的需求。虽然这些确实出现在嵌入式系统中，但它们并没有定义特征。

在某种程度上，处理器或内存的限制排除了使用 C++，甚至 C。供应商可能会在某些处理器上求助于 C 的受限版本来提供高级语言功能，这种努力对于 C++来说是愚蠢的。

但是我们还没有达到这些文章中使用的主板的极限。我们从 Arduino Uno 及其相关产品中看到 C++是可用的。Uno 仅限于 C++的子集，部分原因是开发人员没有可用的 C++标准库。(如果你真的想要一个，有针对 Uno 的[STL 的端口。)Uno 工具集中的编译器支持 C++11，也有一些对 C++14 的支持，但我还没有探究后者，以了解哪些是可用的。C++11 和 C+14 中有一些功能可以提高 C++在嵌入式系统中的使用。](https://forum.arduino.cc/index.php?topic=360116.0)

Due 是一个更大的 Arduino 板，我用来与 Uno 对比，它有完整的标准库。切换到 Raspberry Pi，或者类似的工具，在那里你不仅可以获得 GCC 工具集，还可以在板上运行 Eclipse，感觉就像天空是无限的。

# 该不该 C++？

尽管上述所有观点都是正确的，但它忽略了一个关键点。问题不在于能否在较小的系统上使用 C++，而在于解决这个问题是否需要 C++的能力。我建议把这个问题从“你会用 C++吗？”到“该不该用 C++？”

我们已经解决了一些真正反对使用 C++的基本问题。代码膨胀并不是人们想象的大爆炸。虚函数不是超级慢。但这些评论引发了其他问题。一个评论建议不要使用 C++，因为它隐藏了一些活动。特别提到的是复制构造函数、副作用、隐藏分配和意外操作。

什么是复制构造函数，我们为什么需要它？它是一个复制现有实例的构造函数。每当进行复制时，都会调用复制构造函数。回想一下，所有的构造函数都会初始化实例，这样它们就可以使用了。

如果通过值传递参数，则需要复制构造函数。那是复制品。从函数返回一个值会导致复制，尽管一个好的编译器会把它优化掉。作业也包括复印。

对于内置类型，复制的成本很低，除非你使用 16 字节长的双精度浮点数。对于大型数据结构，复制可能会很昂贵，而且很棘手。与其哀叹 C++做了复制，我们需要认识到它们是必要的。这种认识意味着我们可以努力避免它们，并在需要它们的时候把它们做好。

避免复制的一种方法是通过引用传递结构。在 C #中，通过指针传递就是通过引用传递。C++允许这样做，并引入了引用操作符。引用操作符不仅仅是语法上的糖。例如，引用消除了悬空指针问题，因为不能有空引用。

这带来了指针的所有权问题以及它们对数据结构副本提出的问题。甚至在 C++中，一个数据结构经常包含一个指向另一个数据结构的指针。当你复制的时候，谁拥有指针末端的结构？是复制指针还是数据？如果你只是复制指针，你就在两个副本之间共享数据。一个副本可以修改另一个副本中的数据。这通常不是一件好事。复制数据可能会很昂贵。此外，谁最终决定何时删除指针的目标，或者是否应该删除它？

C++没有引入复制构造函数的问题；它强调了需要解决的需求，有时通过查看问题需求。制作拷贝时，解决方案需要什么？

# 复制数据

在我的机器人工作中，我使用惯性测量单元(IMU)来帮助跟踪机器人的位置和方位。IMU 内部有一个加速度计、一个陀螺仪和一个指南针。加速度计和陀螺仪都提供三重数据，即 x、y 和 z 轴上的测量值。要使这些数据可用，需要对其执行许多操作，比我们在这里想看到的要多得多。但是我们可以看看如何处理这三重数据，以及如何将三重值相加。这是通过陀螺仪完成的，因为它报告每单位时间的角速度变化。通过积累这些读数，理论上你可以获得机器人的方位。

### C++实现

下面是类三元组和重载加法运算符的声明:

```

class Triple {
public:
	Triple() = default; // C++11 use default constructor despite other constructors being declared
	Triple(const Triple&amp; t);	// copy constructor so we can track usage
	Triple(const int x, const int y, const int z);

	const Triple&amp; operator +=(const Triple&amp; rhs);

	int x() const;
	int y() const;
	int z() const;
private:
	int mX { 0 };	// C++11 member initialization
	int mY { 0 };
	int mZ { 0 };
};

inline Triple operator+(const Triple&amp; lhs, const Triple&amp; rhs);

```

我在这里使用了许多 C++11 的特性。它们是有标记的，如果你熟悉 C++的早期版本，它们的含义是显而易见的。带有 *Triple() = default 的行；*大概还不明显。它请求编译器生成默认的构造函数。没有它，我们就不能在构造函数上创建一个没有参数的变量:*Triple T3；。*通常情况下，只有在没有定义其他构造函数的情况下，编译器才会创建默认构造函数。因为*三元组*有另外两个构造函数，所以没有默认构造函数。我使用符号请求了一个，这样就可以创建没有参数的变量。

下一个构造函数， *Triple(const Triple & t)* ，是复制构造函数。这个类不需要它，因为 C++已经默认生成了一个这样的简单类。我创建它是为了展示它是如何工作的，并说明它在哪里被调用。这使用了一个新的 C++11 特性，构造函数可以调用另一个构造函数来处理初始化。这是为了避免经常导致错误的代码重复，或者避免使用类成员来执行初始化。

最后一个构造函数允许我们用三个值初始化一个三元组。这三个值存储在该类的数据成员中。

下一个函数重载了*加等于*运算符。事实证明，实现实际加法运算符的最有效方法(见下面几行)是首先实现这个运算符。

剩下的函数是*getter*，因为它们允许我们从类中*获取*数据。一些类也有*设置器*，允许设置类值。我们不想要三个一组的。

以下是算术运算符的实现:

```

inline const Triple&amp; Triple::operator +=(const Triple&amp; rhs) {
	mX += rhs.mX;
	mY += rhs.mY;
	mZ += rhs.mZ;
	return *this;
}

inline Triple operator+(const Triple&amp; lhs, const Triple&amp; rhs) {
	Triple left { lhs };
	left += rhs;
	return left;
}

```

第一个操作符很简单；它只是将*加等于*运算符应用于类中的每个值，并返回实例作为引用。该运算符修改调用对象中的数据，以便返回的引用有效。

加法运算符在其实现中使用*加* *等于*运算符。这就是复制构造函数发挥作用的地方。我们必须创建一个新的对象来保存结果，所以从 *lhs* 值中创建一个。那是复制品。

使用*加等于*运算符将 *rhs* 添加到新对象中，结果通过值而不是引用返回。返回的是另一个副本。它不能通过引用返回，因为结果对象 *left* 是在函数内部创建的。

任何算术运算符都有两个可能的副本。然而，标准中的 C++特别允许编译器为返回值优化掉副本。这就是*返回值优化*。欢迎您尝试调整代码，但是在这个操作过程中，您无法避免在某个地方创建一两个副本。

这段代码将在 Arduino 上运行，但是我创建了它并在 Linux 上运行它，这样我就可以一步一步地验证复制构造函数在哪里被调用，在哪里没有被调用。

你如何使用这个？几乎和任何算术运算一样:

```

	Triple t1 { 1, 2, 3 };
	Triple t2 { 10, 20, 30 };

	Triple t3 { t1 + t2 };

```

### 实施情况

类似的实现在 C 语言中会是什么样子？这个怎么样:

```

struct Triple {
	int mX;
	int mY;
	int mZ;
};

void init(struct Triple* t, const int x, const int y, const int z) {
	t-&gt;mX = x;
	t-&gt;mY = y;
	t-&gt;mZ = z;
}
struct Triple add(struct Triple* lhs, struct Triple* rhs) {
	struct Triple result;
	result.mX = lhs-&gt;mX + rhs-&gt;mX;
	result.mY = lhs-&gt;mY + rhs-&gt;mY;
	result.mZ = lhs-&gt;mZ + rhs-&gt;mZ;
	return result;
}

```

总的来说，它看起来更短更整洁。结构*三元组*包含轴的三个数据项。例程 *init* 将它们设置为用户指定的值。*加法*函数将两个*三元组*相加并返回结果。 *add* 例程避免初始化*结果*，因为我们知道它的内容将被加法操作覆盖。这对 c 来说是一点节省，当函数返回值的时候仍然有一个副本。你根本无法控制拷贝是如何完成的。在这种简单的情况下，这并不重要，但是对于更复杂的数据结构，比如说，带有指针的数据结构，复制可能更具挑战性。我们可能需要使用带有指针而不是返回值的引用来传递输出参数。

下面是它的使用方法:

```

	struct Triple t1;
	init(&amp;t1, 1, 2, 3);

	struct Triple t2;
	init(&amp;t2, 10, 20, 30);

	struct Triple t3 = add(&amp;t1, &amp;t2);

```

创建并初始化两个值，然后相加。很简单，但是你必须记住获取结构的地址，并确保 *init* 例程只被调用一次。

考虑一下如果实现一个复杂的表达式，两个不同的版本会是什么样子。我只想说我知道我更喜欢哪个。

# 包裹

我开始这篇文章的目的并不是要对这两种语言进行直接的比较。我只想说明，如果你坚持的话，复制构造函数是一种必要的邪恶。在 C++和 C 中，副本出现在多个地方。在 C++中，当使用用户定义的数据类型(即类)时，理解它们变得至关重要。C 语言中的复制不太明显，但仍然是必要的。

因为我不想做比较，所以我没有这两个版本的代码大小和时间。正如我在关于虚函数的文章中指出和演示的那样，在那些参数上比较这些简单的例子通常会产生误导。C++能力是用来解决问题的，而不仅仅是作为语言特性的练习。只有在 C 语言中创建了等价的解决方案，比较才有效。

# 嵌入 C++项目

在 Hackaday.io，我创建了一个嵌入 C++ [项目](https://hackaday.io/project/8238-embedding-c)的 *[。项目将在项目描述中以目录的形式保留这些文章的列表。每篇文章都将有一个项目日志条目用于额外的讨论。感兴趣的人可以更深入地研究主题，提出问题，并分享更多的发现。](https://hackaday.io/project/8238-embedding-c)*

该项目也将作为我或合作者补充材料的地方。例如，有人可能想要获取代码并报告其他 Arduino 板甚至其他嵌入式系统的结果。停下来看看发生了什么事。