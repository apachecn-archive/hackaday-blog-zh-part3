# 有人给我们设置了编译器炸弹

> 原文:[https://hack aday . com/2018/06/03/someone-set-us-up-the-compiler-bomb/](https://hackaday.com/2018/06/03/someone-set-us-up-the-compiler-bomb/)

尽管普通大众对“黑客”这个词有所劫持，但我们并不提倡做颠覆性的事情。然而，研究代码漏洞通常是有用的，既可以作为学术练习，也可以理解您的系统在野外可能会遇到什么样的情况。[Code Explainer]在最近的一篇博客文章中剖析了一个编译器炸弹。

如果你没有听说过编译器炸弹，也许你听说过压缩炸弹。这是一个小 zip 文件，它会“爆炸”成一个非常大的文件。编译器炸弹是一小段 C 代码，它会炸毁一个编译器——在本例中，特指 gcc。虽然[代码解释者]没有创造炸弹，但这归功于[数字创伤]。

我们不确定这有什么实际用途，但它确实说明了一些有趣的问题。首先，代码本身很简单，甚至可能会让你惊讶它居然能工作:

```
main[-1u]={1};
```

链接器显然不关心 main 实际上是一个函数。你可能认为它不起作用，因为它会破坏编译器，但是如果你限制大小以适合你的可用内存，它会创建一个可执行文件。当然，这个可执行文件实际上不会运行，但是。

对我们来说，这看起来不像是利用链接器中的一个奇怪的错误。它工作的原因是编译器在链接阶段耗尽了内存。我们没有尝试，但我们想知道——无保留记忆或其他选项是否会有所帮助。毕竟，您可以想象链接器足够聪明，以“流”的方式初始化静态数组，而不是试图在内存中构建它。就是不行。

如果你对让 gcc [产生*更小的*可执行文件](https://hackaday.com/2013/12/06/trimming-the-fat-from-avr-gcc/)更感兴趣，我们不会责怪你。