# 爬行、行走、奔跑:规划您的第一个 CPU 设计

> 原文:[https://hack aday . com/2016/03/16/crawl-walk-run-planning-your-first-CPU-design/](https://hackaday.com/2016/03/16/crawl-walk-run-planning-your-first-cpu-design/)

我和很多想给计算机编程的学生一起工作过。特别是，他们中的很多人想编写游戏程序。然而，当他们发现几个星期的工作后，他们将无法创建下一个版本的 Skyrim 或 Halo，他们往往会感到失望，并转移到其他事情上。当我还是个孩子的时候，如果你能运行一个基于文本的高低游戏，你就是一个巫师，但显然现在的门槛比过去高了很多。想想“空手道小子”——他必须先“上蜡，下蜡”，才能接触到酷的东西。许多技术项目、编程或其他项目也是如此。

我和很多对 CPU 设计感兴趣的人交谈过，我认为这里也有很多相同的问题。今天的商用 CPU 是庞然大物，具有复杂的内存子系统、指令解释器和超标量执行。这就是 CPU 设计的天缘。也许你应该从简单的开始。当然，你可能想从更简单的项目开始学习 Verilog 或 VHDL。但是 FPGA PWM 发生器和[成熟的 CPU](http://hackaday.com/2015/03/20/the-oldland-cpu-32-bit-fpga-core/) 之间的鸿沟令人望而生畏。

![[Image Source: Amazon]](../Images/bde1f5f3a0d38f14e84781438628f5fc.png)

【图片来源:[亚马逊](http://www.amazon.co.uk/dp/B0006C2T2O)

我对 CPU 设计的大部分了解都来自于卡克斯顿·福斯特的一本旧书，简单来说就是《计算机架构》很多年后，Blue，那本书里的 CPU 成了我的第一个 CPU 设计。是现代的 CPU 吗？一点也不。但是你可能会发现上蜡和脱蜡的程度正好可以让你开始。

## 拿到书

有坏消息也有好消息。坏消息是这本书已经绝版好几年了。好消息是，这本书作为大学课本非常受欢迎，以至于很容易在平常的地方找到轻轻用过的副本(提示:亚马逊)。

有几个版本，但我的评论将是关于第二版，因为这是我的版本。根据版本的不同，蓝色可能会有细微的差异。但是，你不要照搬蓝，只是从中汲取灵感。

这本书会让你对硬件描述语言有所了解，比如 VHDL 和 Verilog。福斯特的书早于这些，并使用了良好的旧逻辑图。这对学习来说很好，但是你可以看到即使是中等复杂的 CPU 在逻辑门中也是如此笨拙。

## 它是如何工作的

[![bluei](../Images/9c5f26116ccd0b8aca93d6ac2ebd4c11.png)](https://hackaday.com/wp-content/uploads/2016/03/bluei.png) 福斯特的蓝色电脑有一个非常典型的 20 世纪 70 年代的小型机架构(就像那个时代的数据通用或数字)。一个 16 位字存储器作为一个统一的数据和指令存储器，最大的 4K 字(大多数商业对应可以处理 32K)。说明屈指可数(嗯，如果 16 是屈指可数；见右)，每个都使用两个主要周期:获取和执行。这些主要周期每个都分为八个时钟阶段。

这就是为什么这种类型的 CPU 是你设计下一代超级计算机的合理起点。避免类似流水线和多指令问题的事情可以让你专注于核心原则。这些原则是每个 CPU 的核心，即使是那些有许多其他细节模糊其基本操作的 CPU。

对于 Blue，有多种资源:寄存器、内存、累加器、算术逻辑单元(ALU)、程序计数器、I/O 等。所有这些都连接到一个公共的内部总线。有些东西只能驱动总线(比如 ALU 的输出)。有些东西只能从总线上读取(比如内存地址寄存器)。有些东西，如累加器或内存缓冲寄存器，两者兼而有之。在给定的周期内，控制单元通过使一个设备能够写入内部总线和至少一个设备能够从总线读取来协调所有这些资源。

内部非常简单，尤其是与现代 CPU 相比。这是 Blue 内部结构的图示视图:

[![bluearch](../Images/67ace7147354f444c2956d034e7c47b9.png)T2】](https://hackaday.com/wp-content/uploads/2016/03/bluearch.png)

控制单元的工作是从内存中读取指令，然后根据这些指令将数据从一个资源(例如内存)移动到另一个资源(例如累加器)。你会注意到 Y 和 Z 与 ALU 之间的虚线。这是因为 Y 和 Z 实际上是 ALU 的输入。输出包括 Y 和 Z 之和、Z 的倒数等等。

获取指令的基本方案是这样的(福斯特数字从 1 开始，所以我也会):

*   Fetch 1:将计数器(PC)编程到总线，从总线加载内存地址寄存器，从总线加载 ALU 参数 Z，进行内存读取
*   获取 2:将常数 1 放在总线上，从总线加载 ALU 参数 Y
*   获取 3:等待内存访问
*   获取 4:将 Z+Y 放在总线上，从总线加载 PC
*   Fetch 5:将内存加载到内存缓冲寄存器
*   获取 6:将内存缓冲寄存器放在总线上，加载指令寄存器
*   获取 7:可用
*   获取 8:可用

我省略了一些不适用于现代系统的细节。例如，Fetch 5 周期的一部分是将数据重写到 Blue 的[核心存储器](http://hackaday.com/2016/03/08/thanks-for-the-memories-touring-the-awesome-random-access-of-old/)。这对于现代记忆系统来说是不必要的。

提取周期的工作是读取程序计数器中的指令，并将程序计数器加 1。Fetch 1 是一个很好的例子，说明控制单元在一个子周期内执行两次写操作，因为程序计数器必须访问存储器地址寄存器和 z。

对于简单的指令，可以在第 7 和第 8 次取指令时执行。这些指令可以放在一个主周期中，不需要执行周期。例如，NOT 指令反转累加器，因此该指令的 Fetch 6 可以将累加器放在内部总线上并加载 z，然后最终的 Fetch 子周期可以将 ALU 输出移动到累加器。此外，它还必须标记控制单元，以开始新的提取周期，而不是执行周期。在 Blue 的原始设计中，状态标志控制这一点，默认情况下，从来没有执行周期。因此，在 NOT 指令的情况下，什么也不做就足以满足下一个周期是提取的要求。

然而，一些指令需要更多的工作。在那些情况下，提取 8 子周期将状态设置为“E”(用于执行)。这为控制单元提供了另外 8 个子周期来响应指令操纵资源。这对于访问内存的指令尤其重要，因为你必须有另一个不取指令的内存访问周期。有了现代的高速内存，你也许可以把所有的东西压缩成 8 个阶段的读取，但是记住 Blue 的内存相对较慢，在读取之后需要刷新。任何执行周期中的最后一步是将状态重置为“F ”,以便下一个周期是一个提取周期。Blue 不需要它，但是理论上，如果你有需要多个周期的指令，状态可以不止一位(所以你可以有 Execute 0，Execute 1，等等)。

控制单元如何知道该做什么？每条指令都有一个 4 位操作码(第 15-12 位)，其余的位指定一个地址(现在你明白为什么 Blue 只能处理内存的 4K 字了)。一旦指令在指令寄存器中，解码高 4 位决定接下来的周期发生什么。

## 履行

你最有可能用 Verilog 或 VHDL 实现逻辑(尽管，你可以像 Foster 一样使用模拟包来画门，或者你可能想在[《我的世界》](http://hackaday.com/2012/05/20/building-a-6502-in-minecraft/)中构建它)。无论你怎么做，概念都是一样的。

您将获取所有 16 条指令，并为它们构建取指令周期(并为您需要的指令构建执行周期)。然后，您可以创建逻辑来执行所需的每个操作。所有这些是相同的得到合并与一个或门，并馈入寄存器或其他资源，使它做它应该做的事。

资源很简单。你把总线装入一个寄存器，或者你把寄存器输出到总线。ALU 在内部执行简单的逻辑，但除此之外，它只是一个寄存器，并不只是将输入写回。所有“智能”部分都在控制单元中。

考虑提取周期的阶段 4。它应该让 ALU 将和输出选通至总线，然后让 PC 从总线读取(这是 CPU 设置下一个读取地址的方式)。在福斯特的设计中，这是一个单与门。一个输入是 F 位(表示一个提取周期)，另一个是 CP4(表示第 4 个子周期)。输出扇出到 ALU 的和输出门和 PC 的负载输入。

据推测，其他东西会想要选通 sum 输出(ADD 指令)或加载 PC(JMP 指令)，因此这些输出将真正进入连接到相关资源的 or 门(见下图)。例如，和输出门也将连接到与门，该与门将 AND 指令解码与 F 的反相(指示执行周期)和 CP8 合并。相同的输出将驱动累加器从总线读取数据(同样，通过一个或门，该门合并所有表示累加器加载的信号)。

[![](../Images/3bd097f4d21530380ba9102791885f43.png)T2】](https://hackaday.com/wp-content/uploads/2016/03/bluelogic-1.png)

这样看的话，CPU 很简单。只是总线上的一群读者和作者，以及在不同时间启用不同项目的状态机。资源有时被称为 CPU 的[数据路径](https://en.wikipedia.org/wiki/Datapath)，资源是功能单元。

## 淘汰旧的

我已经提到过 Blue 的核心内存特性在今天几乎没有必要。在 Blue 的设计中，您可能需要(或想要)纠正一些其他项目。快速记忆可以让你优化一些蓝色的周期。特别是，如果你想的话，你可以在每个阶段读写内存。你可以让 PC 知道如何递增自己，这样操作就可以与使用内部总线的某个设备共享一个插槽。

不过，最大的变化可能是时钟一代。福斯特使用延迟线来制作 8 相时钟。现代设计师不喜欢使用这样的延迟有几个原因。首先，组件的变化使得短延迟很难均衡，尤其是在不同的机器上。第二，组件会随着时间和环境因素而变化，因此像这样的延迟需要精心设计才能切实可行。

然而，我认为即使是福斯特也不喜欢这样的设计。书中的一个练习题要求你思考产生时钟的不同方法。我认为，对一个现代设计师来说，最明显的是以 8 倍于所需频率的频率制作一个时钟，并驱动一个 3 位计数器。然后将计数器解码成 8 路输出。或者，您可以使用一个 8 位移位寄存器，只在每个时钟脉冲上循环一次。

输入输出指令有点过时了。指令本身并不坏*，因为它们只是从指令的地址字段(嗯，字段的一部分)中指定的设备读取或写入。然而，逻辑是为纸带穿孔机和阅读器之类的东西设置的。你会想要改变的。在我的设计中，我将 I/O 结构简化了很多。*

 *## 下一步是什么？

您可能想知道 Blue 的实际实现是什么样子。我会留到下次。然而，这一点不应该是复制我在 Verilog 中的实现。它应该是使用您选择的工具来完成您自己的架构呈现。福斯特的书里至少有一个 bug(至少在第二版里)，你需要将设计现代化一点。然而，创造你自己的蓝色是发展你作为一个 CPU 设计师的技能的好方法。

接下来会发生什么？福斯特书中后面的章节谈到了 Indigo，另一种类似的机器，但具有更现代的寻址模式(如索引寻址)。那有一些价值，但是如果你能通过蓝色工作，你也许能自己弄明白。还有其他一些有趣的功能(比如中断)，但并没有真正推动 Blue 接近现代设计。

![HP1000 Reference via the Internet Archive](../Images/4f3a5f9147536b2380e8fe26d19c3464.png)

HP1000 Reference via the [Internet Archive](https://archive.org/stream/bitsavers_hp1000AserDJun84_35043666/02137-90005_A700_ERD_Jun84#page/n0/mode/2up)

如果你想使你的设计现代化，下一步就是微编码(福斯特在第 8 章中提到了这一点)。如果你想到蓝色的控制单元，它几乎可以是一个小计算机本身，运行简单的程序，操纵功能单元。这就是大多数现代 CPU 的工作方式。他们开发控制，直到作为一个非常简单的 CPU(实际上就像一个剥离下来的蓝色)，并使用它来实现真正的 CPU 控制。有些计算机，如旧的 HP1000，甚至可以让你用微码创建自己的指令。

Blue 需要的另一大改进是流水线技术。流水线背后的思想是获取和执行可以重叠。如果蓝色被流水线化，那么当第一条指令在 CP8 周期时，第八条指令将在 CP1。在 8 条指令之后，CPU 将在每个次时钟周期执行一条指令，而不是每 8 个次时钟周期执行一条指令。

听起来很棒，但是还有细节。例如，存储指令可能引用尚未准备好的结果。特殊的逻辑必须捕捉这种情况并停止流水线。条件跳转也会导致问题，因为你必须在跳转时清除管道，以防止不应该运行的指令完成。对于条件转移来说，这是一个真正的问题，你可能不知道一段时间内是否会转移。

如果你正在寻找更现代的蓝色，我强烈推荐 2000 年左右的[Jan Grey's] [XSOC](http://www.fpgacpu.org/xsoc/cc.html) 。它也使用原理图，但有一个哈佛架构的流水线 RISC CPU。不过，这可能是你的 CPU 设计之旅中更好的第二站。下次我将向您展示 Blue 的 Verilog 实现。在此之前，您可能会喜欢在下面的视频中与 CPU 进行终端会话。

 [https://www.youtube.com/embed/ixwPUywv-iU?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent](https://www.youtube.com/embed/ixwPUywv-iU?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent)

T2】*