# 第四:黑客的语言

> 原文:[https://hackaday.com/2017/01/27/forth-the-hackers-language/](https://hackaday.com/2017/01/27/forth-the-hackers-language/)

让我们从一个有争议的说法开始:第四是黑客的编程语言。对于一个不存在的奇怪的 CPU 架构，用 Forth 编写代码有点像交互式地编写汇编语言。第四是一个虚拟机，一个解释的命令行，和一个编译器。所有这些都很简单，很容易在几千字节的内存中运行。当你的第四个代码是正确的，它读起来就像一个自然语言的句子，但要达到这一点需要一点解谜。

[![robot_forth_had-colors](../Images/153a3d02e323aa1a0af84f5ca769093d.png)](https://hackaday.com/wp-content/uploads/2017/01/robot_forth_had-colors.png)

From [Thinking FORTH](https://www.forth.com/forth-books/) (PDF)

第四，如果 Python 和汇编语言睡在一起，你会得到什么:交互式的、富于表现力的、没有语法负担的，但仍然非常接近金属。是高级语言还是低级语言？是啊！或者说，这是从一个地方到另一个地方的最短路径。在 Forth 中，您可以而且必须直接查看和查看内存，但是您也可以足够快地构建一个更高级别的代码体，而不会介意。在我看来，这种现场编码和接近硬件的结合对于探索新的微控制器或者将它们应用到您的项目中是非常有益的。用这种语言编写硬件抽象层很有趣。

但是 Forth 也像一个走钢丝的行为；如果 C 给你足够的绳子上吊，那么 Forth 就是爬满眼镜蛇的喷火器。没有类型检查，没有范围，也没有数据和代码的分离。你可能会做一些可怕的事情，比如将`2`重新定义为一个返回 7 的函数，然后你的数学将永远无法工作。(但是为什么*会*你呢？)你可以很容易地跳到坏的内存区，使系统崩溃。您将开发一个良好的心智模型，以了解在任何给定的时间栈上有什么数据，否则您将遭受损失。如果你想让编译器替你担心代码安全，去看看 Rust T4、Ada 或 Java。你在这里找不到它。第四是简单性和灵活性。

简单灵活也意味着可扩展。默认情况下，大多数 Forth 系统几乎不包含任何东西。例如，如果你喜欢面向对象风格的编程，Gforth 提供了不少于[三种不同的对象框架](http://www.public.iastate.edu/~forth/gforth_49.html)，你可以选择最适合你的问题或风格的。您可以修改 Forth 编译器或解释器本身，所以如果您想要类型检查，您可以添加它。有些 Forth 实现只用二三十个函数用原生汇编或 C 编写，其余的用 Forth 引导。更快的 Forths 完全是用汇编语言实现的，通过一些编译时优化，它可以像其他任何东西一样快地运行，即使它是在目标微控制器上编译的。

如果你正在设计一个企业银行后台，那么 Forth 可能不是你想学的语言。另一方面，运行物理模拟的一串闪亮的发光二极管不是“企业”的东西。第四是黑客的语言，既有褒义也有贬义。我不确定它是否能帮助你完成“真正的工作”,你们这些工程师可能现在就想离开。但是，如果你想调整语言本身，或者用它来推动你的硬件，或者只是*玩*，Forth 是很棒的。作为一名黑客，我认为这很有趣，非常适合小型微控制器项目。

## 第四个速成班:理论部分

Forth 是继汇编语言之后最简单的语言。Forth 是[过程化](https://en.wikipedia.org/wiki/Procedural_programming)的极端——Forth 程序实际上只是一系列子程序，在 Forth 行话中称为“单词”。没有语法，所有单词都用空格隔开，从左到右解析。除了几个编译例外，所有的单词现在都运行*，所以第四个解释器不必向前看下一个单词。如果你已经定义了单词`run`、`this`和`code!`，那么`run this code!`是有效的，它按照你期望的顺序调用这三个单词。*

 *### 简单性和反向波兰符号

这个简单设置的必然结果是 Forth 使用了所谓的反向波兰符号(RPN)。如果第四个解释器现在要执行`+`字*，它必须已经在堆栈上有两个要相加的数字。否则，它必须等待下一个数字出现，才能完成加法。再读一遍，让它深入人心。和你习惯的不一样，很重要。*

 *[![crazy](../Images/4792ba2ef1517c55649833c98c271b27.png)](https://hackaday.com/wp-content/uploads/2017/01/crazy.png) 任何其他排序或语法都是不必要的复杂。你认为写下数学是“自然”的方式是疯狂的，因为`+`操作符的前瞻性质要求要么用括号要么用“运算顺序”来明确。看`2 + 3 * 4`。这里得到 14 一点也不自然——这是隐含规则的复杂语法的结果。你必须先读完整个“句子”，找到`*`，记住它优先于`+`，先对它求值，然后再回到加法上去完成，尽管`+`是句子中的第二个单词。计算机不想知道“运算顺序”，它只想把两个数字相加，最好是已经在 ALU 寄存器中的数字。不相信我？读取机器代码。

第四，和 RPN，把这个写成`2 3 4 * +`或者`3 4 * 2 +`。无论哪种方式，操作员都处理任何已经可用的数字。如果你不认为这是“反向”或“润色”，甚至是“符号”，你就在正确的轨道上。你只是简单地把事情按照应该执行的顺序写下来。(那有多疯狂！？！)

我喜欢把 RPN 看作是计算上的等同物*mis en place*；在你开始烹饪之前，你把所有的配料都排好。这是代码工作的方式:`get.broccoli chop.broccoli get.beef slice.beef get.oyster-sauce stir.fry`有些元素自然是可以互换的——你可以在切西兰花之前先切牛肉——但是整体顺序对这个过程很重要，你真的不想在牛肉还在锅里的时候再去切西兰花。但是当你坚持写`3 + 4`而不是`3 4 +`时，这正是你正在做的。

### 编译和运行

定义和编译新单词，使用`:`进入编译模式，使用`;`退出。像这样的编译会立即进行。在引擎盖下，第四个解释器正在查找您在定义中使用的每个单词，并简单地将它们串在一起。这条规则的一个例外是函数名本身，正如您现在将看到的。

[![stack_ops_had-colors](../Images/fc06d787e7fe2729a672d6135ac8beb7.png)](https://hackaday.com/wp-content/uploads/2017/01/stack_ops_had-colors.png)

[Starting FORTH](https://www.forth.com/starting-forth/0-starting-forth/)

编译你的第四个单词:`: seven 3 4 + ;`。这不是很有用，但它创建了一个名为`seven`的字，将 3 和 4 放入堆栈，然后运行加法字。“结果”是，无论你之前在堆栈上有什么，你现在都会在它上面有一个 7。一个优化的 Forth 编译器会将一个 7 压入堆栈。

所有的编程都是将复杂的任务分解成合理大小的块。什么构成“合理”一点取决于语言，一点取决于程序员自己的风格，一点取决于文化时代精神。在 Forth 中执行一个单词比在 C 中执行一个函数调用需要更少的开销，即使对于有经验的 Forthers 来说，遵循长代码逻辑也会变得复杂，所以 Forth 单词的定义往往非常短，通常是包含注释的一行代码。你会经常编译。

### 堆栈

Forth 的核心和灵魂是数据堆栈，以下简称“堆栈”。Forth 是一种基于堆栈的语言，除非你用 Forth 编码一段时间，否则你无法理解这到底意味着什么，以及关于堆栈的想法是如何主宰你的编码生活的。Forth words 不接受参数或返回值，而是在被调用时对栈上的任何数据进行操作。

[![stack_spring_had-colors](../Images/fcbe1d23f73df60363f56c8c68367f45.png)](https://hackaday.com/wp-content/uploads/2017/01/stack_spring_had-colors.png)

[Starting FORTH](https://www.forth.com/starting-forth/0-starting-forth/)

堆栈是 Forth 中最好也是最差的部分。当你的栈内容与操作它们的字对齐时，结果是无与伦比的美丽和效率的代码。当它们错位时，您会发现自己怀疑面向对象的人是否是对的，以及将数据与方法耦合到底是不是一个好主意。

Forth 编程中的诀窍是通过一个单词计算出堆栈中需要什么，并确保之前使用的单词在堆栈中留下该单词。从这个意义上说，第四个程序员定义了单词，但需要用短语来思考，堆栈的内容从空开始，然后又以这种方式结束。这就像 C 在函数范围内使用堆栈的方式，只保留局部变量直到函数结束，然后覆盖它们。

作为这种链接的具体示例，想象一个将 GPIO 引脚设置为高电平的单词`gpio-set`。它可能需要一个端口和一个 pin 号码来完成这项工作。实现这一点的第四种方法是为你要使用的器件上的每个引脚定义一个单词:`: PA3 PORTA 3 ;`然后你可以用`PA3 gpio-set`点亮引脚 A3 上的 LED。在 C 语言中，首先定义一个包含端口和 pin 号的结构，然后定义`gpio-set`来获取该类型的结构。在 Forth 中，这是隐式的:您要确保 pin 字将端口和 pin 号推送到堆栈上，然后 pin 处理字需要它们。不安全，但是很简单。

### 堆叠杂耍

[![Swap-swap, the Forth Mascot, from Starting FORTH](../Images/77e2442408677cd441776c5a712bfc56.png)](https://hackaday.com/wp-content/uploads/2017/01/ch2-swap-swap_had-colors.png)

Swap-swap, the Forth Mascot, from [Starting FORTH](https://www.forth.com/starting-forth/0-starting-forth/)

Forth 最糟糕的部分是堆栈操作。人们通常通过学习栈操作来开始学习，的确它们很重要，但是它们很琐碎。像`swap`、`drop`和`dup`这样的词可以让你在栈上移动项目，但是在一个给定的词中太多的“栈杂耍”操作可能是坏的 Forth 代码的标志，而不是好的。你肯定会用这些词，但那不是埋尸体的地方。

相反，堆栈是处理步骤之间绝对最小量的数据想要存放的地方。当然，条目的数量需要足够少，以避免耗尽有限的堆栈空间。但是第二个原因是很难在你的头脑中保持太多的堆栈项目。当你习惯于 Forth 时，你可以内化的栈的数量可能会从三个增加到五个或七个，但是如果你让栈长时间增长而不被内化，你会感到困惑。

如此等等是一场灾难。在这种语言中，您必须自己管理堆栈，不陷入无休止的堆栈杂耍的唯一希望是尽可能保持简单。第四条的支持者会声称这也是它最大的优点——总是有保持事情简单明了的压力，因为做任何其他事情都会把不可预测的错误深深地嵌入到你的代码中，以至于你会发疯。我不知道这是不是斯德哥尔摩综合症，也不知道我本质上是不是一个极简主义者，或者我是否喜欢挑战，但这实际上是 Forth 如此简洁的原因之一。

其他编程语言允许你处理几十个变量，因为编译器会为你跟踪不同的作用域，跟踪每个(局部)变量在堆栈中的深度。Forth 没有。这意味着你需要考虑事情运行的顺序。Forth 迫使您内化一点优化，这是一个理想的编译器会为您做的。这可能会导致非常紧凑的代码，或者令人头痛。这取决于程序员和问题。

以我的经验来看，简单的语法，计算机友好的排序，以及由此产生的对透明性和简单性的强调，使得把东西放在前面变得非常容易。

## 最佳地点

但是关于第四的哲学废话已经够多了。如果你想要，你可以在别处大量阅读。(参见下面的词汇表。)现在，硬件黑客比以往任何时候都更感兴趣的原因有三个。第一个原因是，Forth 是为 20 世纪 70 年代末和 80 年代初的计算机开发的，这种级别的功能和复杂程度差不多就是现在市场上每台 3 美元的微控制器的功能和复杂程度。其他两个原因交织在一起，但都围绕着一个特定的 Forth 实现。

### 梅克里斯普-斯特拉里斯

有一百万个第四，每一个都是一片特别的雪花。我们已经为 AVR 报道了[第四次，为 ARMs](http://hackaday.com/2013/10/12/a-simple-forth-development-board/) 报道了[第四次，最近为 ESP8266](http://hackaday.com/2015/08/30/go-forth-on-a-breadboard/) 报道了[第四次。有个笑话说，如果你看到了第四个实现，你就看到了第四个实现。但我认为这太愤世嫉俗了——Forth 既是一种特殊的实现，也是一种思考计算机编程问题的方式。一旦你学会了一种，你就有了学习其他任何一种的良好基础。](http://hackaday.com/2016/12/23/interactive-esp8266-development-with-punyforth/)

不管怎样，几年前，一个物理学研究生[马蒂亚斯·科赫]为 MSP430 写了一个 Forth，因为他需要一个微控制器来为一个实验收集模拟数据。那是“Mecrisp”。后来，他需要更快的速度，并为 ARM Cortex M 系列芯片重新编写了它，我们得到了“ [Mecrisp-Stellaris](http://mecrisp.sourceforge.net/) ”。

这就是事情变得令人敬畏的地方。JeeLabs 中的“J”【Jean-Claude WIP pler】决定在 Forth 实施他的分布式电气和环境传感器新系统，至少在引擎盖下。为此，他需要一个硬件抽象层。 [Mecrisp-Stellaris](https://github.com/jeelabs/mecrisp-stellaris) 与 [JeeLabs 库](https://github.com/jeelabs/embello/tree/master/explore/1608-forth)的结合是一个巨大的第四代生态系统，适用于一大堆 ARM 微控制器，这一切都是由一小群有思想的黑客在过去两年内开发的。将两者结合起来提供了一种非常愉快的 Forth 微控制器黑客体验，就像一种怪异的交互式 Arduino。

## 你的作业

因此，如果你想继续探索一个非常奇怪的兔子洞，学习一点真正的黑客编程语言，或者只是闲逛，请继续关注。几周后，我将发布一份关于在 STM32 系列 ARM 芯片上使用 Mecrisp-Stellaris 的实用指南。

[![These are the droids you're looking for.](../Images/6b024160c3153d6829224ca2f5d14ab0.png)](https://hackaday.com/wp-content/uploads/2017/01/dscf9187_bright_thumbnail.png)

These are the droids you’re looking for.

一个好的最小 Mecrisp-Stellaris 开发环境将由一个便宜的 STM32F103 开发板、一个 ST-Link v2(或更好的)编程器和一个 USB-TTL 串行适配器组成。很有可能你至少已经拥有了后者。如果是这样的话，剩下的 10 美元、10 欧元或 10 英镑就够了，这取决于你住在哪里。“STM32F103”和“ST-link”应该可以让你在易贝上设置好。

所以现在就订购一些零件。在你等待送货的时候，浏览一下[这个非常好的在线教程](http://skilldrick.github.io/easyforth/)。把这个做完，下次你就可以开始了。

如果你想更进一步，你可以[为你的台式电脑下载第四个](https://www.gnu.org/software/gforth/),并开始学习其他一些介绍。布罗迪的“Starting FORTH”是[规范的 FORTH 介绍](https://www.forth.com/starting-forth/1-forth-stacks-dictionary/)，但它有点过时(可以随意跳过第三章的磁盘访问)。如果你更喜欢简洁而不是幽默，看看 J.V. Noble 的[初学者指南](http://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm)或 [Gforth 教程](http://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Tutorial.html#Tutorial)。

从开始使用的所有图像都获得了 [FORTH，Inc.](https://www.forth.com/) 的许可。原始图像是黑白的，而不是常见的深炭色和黄色。**