# 在 Arduino 上运行微积分

> 原文:[https://hack aday . com/2016/01/18/running-calculus-on-an-arduino/](https://hackaday.com/2016/01/18/running-calculus-on-an-arduino/)

那是星际日期 2267。一种被称为雷德雅克的神秘生命体拥有企业号的计算机系统。精通计算机操作和数学，[斯波克]指示计算机计算圆周率到最后一位数字。他会说:“*…圆周率的值是一个没有分辨率的先验数字*”。计算圆周率的任务给计算机呈现了一个无限的过程。计算机将不得不永远处理这个任务，最终迫使 Redjac 退出。

微积分依赖于无限的过程。Arduino 是一台(单线程)计算机。因此，在 Arduino 上运行微积分功能的想法似乎是不可能的。在本文中，我们将探讨在微控制器中使用类导数技术的想法。让我们记住，导数提供了瞬时变化率。当函数已知时，很容易得到瞬时变化率。然而，当你使用一个微控制器并在没有已知功能的情况下改变模拟数据时，就不那么容易了。我们的目标是获得数据的平均变化率。由于微控制器比输入数据的变化速率快很多个数量级，因此我们可以计算很短时间间隔内的平均变化速率。我们的工作将基于这样的事实，即平均变化率和瞬时变化率在短时间间隔内是相同的。

## 休斯顿，我们有麻烦了

在本系列的[第二篇文章中，结尾有一个名为“额外学分”的部分提出了一个问题，并要求读者解决这个问题。今天，我们要解决这个问题。事情是这样的:](http://hackaday.com/2015/12/22/calculus-is-not-hard-the-derivative/)

我们有一台机器可以把液体加入一个封闭的容器中。这台机器通过测量容器内的压力变化来计算加入的液体量。玻意耳定律是一个非常古老的基本气体定律，它认为封闭容器中的压力与容器的体积成反比。如果我们把容器变小，里面的压力就会上升。因为液体不能被压缩，将液体引入容器有效地使容器变小，导致压力增加。然后，我们将压力的增加与加入的液体体积相关联，得到校准曲线。

问题是有时液体会用完，而气体会注入容器中。当这种情况发生时，机器变得不起作用。我们需要一种方法来判断气体何时进入容器，这样我们就可以停止机器并警告用户没有液体了。

一种方法是利用这样的事实，即当加入气体而不是液体时，容器中的压力将以更大的速率增加。如果我们能测量加法过程中容器内压力的变化率，我们就能区分气体和液体。

## 衍生产品快速回顾

在我们开始之前，让我们快速回顾一下导数是如何工作的。我们在这里详细讨论了[导数，但是我们将在下面的段落中总结这个概念。](http://hackaday.com/2015/12/22/calculus-is-not-hard-the-derivative/)

![zeno_10](../Images/30394a3ff1203959786e3466d515d76d.png)

Full liquid add

平均变化率是在一段时间内位置的变化。速度是变化率的一个例子。例如，一辆时速 50 英里的汽车每小时以 50 英里的间隔改变它的位置。导数给了我们一个瞬时变化率。这是通过获得平均变化率，同时使测量之间的时间间隔越来越小来实现的。

让我们想象一辆汽车在零时刻停在一英里处。一小时后，它在 51 英里标记处。我们推断汽车的平均速度是每小时 50 英里。一英里标志处的速度是多少？我们如何计算呢？[伊萨克·牛顿]会建议我们开始在更短的时间间隔内获得平均速度。我们刚刚计算了 1 英里和 51 英里之间的平均速度。让我们计算英里标记 1 和 2 之间的平均速度。然后里程标是 1 和 1.1。然后 1 和 1.01，然后，1.001…等等。随着我们测量的时间间隔越来越短，我们开始在一英里标记处的瞬时速度上收敛。这是导数背后的基本原理。

## 平均变化率

![zeno_11](../Images/79238b2ed8f9ec1f5355ca506eaf0085.png)

Gas enters between time T4 and T5

我们可以用类似的方法测量压力，来区分气体和液体。此过程的变化率单位是 PSI 每秒。随着液体的加入，我们需要计算这个速率。如果它变得太高，我们知道气体已经进入容器。首先，我们需要一些数据来处理。让我们制作两个控件。我们将得到正常液体添加的压力数据，如左上图所示。另一个是液体用完时的压力数据，如右图所示。从视觉上看，很容易看出气体何时进入系统。我们看到时间的 T4 和 T5 之间的激增。如果我们计算 1 秒时间间隔之间的平均变化率，我们会发现除了一个时间间隔之外，其他时间间隔都小于 2 psi/sec。在气体图上的时间 4 和 5 之间，平均变化率是 2.2 psi/sec。次高的变化是时间 T2 和 T3 之间的 1.6 psi/秒。

所以现在我们知道我们需要做什么了。当变化率超过 2 psi/sec 时，监控变化率和错误率。

我们的伪代码看起来像这样:

```
x = pressure;
delay(1000);
y = pressure;
rateOfChange = (y - x);
if (rateOfChange > 2)
    digitalWrite(13, HIGH);  //stop machine and sound alarm
```

## 瞬时变化率

看起来，查看 1 秒时间间隔内的平均变化率是我们解决问题所需要的。如果我们想获得特定时间的瞬时变化率，我们需要将 1 秒的时间间隔变小。让我们记住，我们的微控制器比变化的压力数据快得多。这使我们能够计算很短时间间隔内的平均变化率。如果我们让它们足够小，平均变化率和瞬时变化率本质上是一样的。

因此，我们需要做的就是让延迟变小，比如 50 毫秒。你不能让它太小，否则你的变化率将为零。延迟值需要通过一些老式的反复试验来适应特定的机器。

## 在微控制器中发挥极限？

我们还没有触及的一件事是微控制器内部的极限概念。主要是因为我们不需要。回到我们的汽车例子，如果我们可以计算出汽车在 1 英里标记和 0.0001 英里标记之间的平均速度，为什么我们需要经历一个限制过程？我们已经有了一次计算的瞬时变化率。

有人可能会说，导数背后的思想是在经历一个极限过程的同时收敛于一个单一的数字。对于未知函数的输入数据，有可能做到这一点吗？我们试试，好吗？我们可以利用输入数据的变化率和处理器速度之间的巨大差距来制定计划。

让我们重温一下我们最初的问题，建立一个数组。我们将每 10 毫秒用压力数据填充数组。我们等待 2 秒钟，获得 200 个数据点。我们的目标是通过取一个极限并收敛到一个单一的数来得到中间数据点的瞬时变化率。

我们首先计算数据点 100 和 200 之间的平均变化率。我们将值保存到一个变量中。然后我们得到点 100 和 150 之间的变化率。然后，我们通过取差值将结果与之前的比率进行比较。我们继续这一过程，获取越来越短的时间(从第 100 个数据点开始)之间的变化率，并通过取差值来比较它们。当差值很小时，我们知道我们已经收敛到一个值。

然后我们在相反的方向重复这个过程。我们计算数据点 0 和 100 之间的平均变化率。然后 25 和 100。然后是 50 和 100 等等。我们像以前一样继续这个过程，直到我们收敛到一个单一的数字。

如果我们的想法可行，我们会得到两个值，看起来像 1.3999 和 1.4001，我们说 T1 的瞬时变化率是 1.4 psi 每秒。然后我们就一直重复这个过程。

现在轮到你了。你认为你有能力编写这个极限程序吗？