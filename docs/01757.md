# 嵌入埃利奥特:三月 Makefile 疯狂

> 原文:[https://hack aday . com/2016/03/11/embed-with-Elliot-March-makefile-madness/](https://hackaday.com/2016/03/11/embed-with-elliot-march-makefile-madness/)

[`make`工具下个月将迎来 4-0 大赛](https://en.wikipedia.org/wiki/Make_%28software%29)，我们想我们应该早点开始庆祝活动。在这个由两部分组成的系列中，我将介绍一些我认为特别有用的`make`背景知识，然后重点介绍微控制器专用的应用。如果您仍然在剪切和粘贴一个通用的 makefile 来运行您的工具链，希望您能在这里获得足够的洞察力来开始开发自己的工具链。它比看起来要简单得多！

就在 C 编程语言被发明，项目开始变得比“hello world”大一点的时候，很明显需要一些工具来组织和自动化编译。毕竟，如果你有一个分布在许多文件、模块或库上的程序，那么每当你对一段代码进行修改时，都必须重新编译它们，这是一件麻烦的事情。如果有些部分没有改变，重新编译它们只是在浪费时间。但是谁能跟踪所有这些呢？`Make`可以！

事实上，`make`可以做任何事情。它非常擅长处理通用规则来解决文件间复杂的依赖链。它知道哪些文件在这个过程中发生了变化，并且只重新构建完成工作所必需的文件。而且它高度可扩展——你可以通过精心制作的 makefiles 训练`make`做任何事情。我曾经使用`make`自动将分数更新通过电子邮件发送给那些分数发生变化的学生。

在这个 ide 和 GUI 驱动开发的时代，用编辑器、编译器和 makefile 编写代码还是有好处的。但是 makefiles 可能非常复杂。看看由 Eric Weddington 和 rg Wunsch 编写的“标准”AVR makefile 。十年来，我在无数的项目中使用过这个文件，但没有认真通读和理解它——它做的太多了。同样，[sudar]的 makefiles 将[为你编译 Arduino 代码，而无需接触 Arduino IDE](https://github.com/sudar/Arduino-Makefile) 。当你需要它的时候，这很好，但是它需要 1500 行代码。

一个通用的神奇 makefile 并不是一件坏事，除非你想了解`make`系统是如何工作的。在这种情况下，所有的一般情况下，特殊情况下，和镀金百合只是得到的方式。我认为对于许多项目来说，编写一个快速的特定于项目的 makefile 是一个很好的实践。它使事情变得简单，并有助于确保您知道实际发生了什么。

因此，我们将从一个绝对最小的 makefile 文件开始，并朝着对大多数项目更合理的方向努力。在这个过程中，我将使用`make`给你的一小部分工具。为什么？因为大多数特性都是针对这种特殊(或一般)情况的，在实践中你几乎不会用到它们。我在这里的目标是让你足够好地理解`make`系统，以至于你不需要一个 IDE 来完成你的编码。

## 有时候最酷的 Makefile 根本就不是 Makefile

那么可以用来编译项目的最小 makefile 是什么呢？你会完全不相信吗？系统内置了大量的功能。我希望您将 makefile 看作是对固有功能的扩展或定制。

为了让你明白我的意思，下面是用 C 语言写的“hello world ”,它是为我的台式电脑编写的:

```

#include &lt;stdio.h&gt;

int main(void)
{
    printf(&quot;hello world!\n&quot;);   
    return 0;
}

```

输入，保存在一个名为`hello.c`的文件中，你就可以开始编程了。接下来，您需要编译并运行它。假设您使用`gcc`作为编译器，您可以输入类似`gcc hello.c -o hello`的内容，然后在完成后运行结果程序(Unix/Mac 上的`hello`，Windows 上的`hello.exe`)。

老实说，打字没什么大不了的，但是简单地打字有多酷呢？酷多了。但更重要的是，它表明`make`已经知道如何做一些简单的事情，比如将 C 代码编译成可执行程序。即使没有`makefile`在场，键入`make hello`也会为您运行下面的命令:`cc hello.c -o hello`——几乎和我们上面手工做的一样。

## 一路向下的规则

它是怎么做到的？有预定义的规则来创建与其他文件不同类型的文件，它非常聪明地将这些规则链接起来，使您的项目顺利进行。因此，举例来说，如果你需要构建`hello.hex`来闪存到你的微控制器中，有一个从`hello.elf`生成`hello.hex`的规则，有一个从`hello.o`(可能还有一些其他对象文件)生成`hello.elf`的规则，有一个从`hello.c`生成`hello.o`的规则，那么`make`会将它们链接在一起以完成任务。

作为一个例子，让我们写出一个显式规则，这样我们就可以看到它是如何工作的:

```
hello: hello.c
    gcc hello.c -o hello

```

第一行告诉`make`我们的可执行文件`hello`依赖于`hello.c`。接下来的制表符缩进行是告诉 make 如何从依赖项到达目标的规则。事实上，如果你把这个写到 makefile 中，你就差不多回到了没有 makefile 的地方。

随着项目子部分数量的增加，Makefiles 开始变得有趣起来。假设我们现在已经将代码分成了两个模块，我们想将它们编译在一起。处理这种情况的一种方法是显式包含依赖关系:

```
hello: hello.c extras.c
    gcc hello.c extras.c -o hello

```

但是你可以看到，随着我们包含越来越多的源文件，我们将有更多的打字工作要做。我们可以定义一个变量来保存所有的源文件:

```
SRC=hello.c extras.c
hello: $(SRC)
    gcc $(SRC) -o hello

```

我们的目标`hello`依赖于`SRC`变量中列出的所有源文件，所有这些都包含在编译命令中。这是一个不错的解决方案，可读性很好，这是一个优点。但是正如我们在没有使用任何 makefiles 文件时所演示的，`make`已经有了内置的规则来处理像这样的简单情况。我们应该利用它们。

## 自定义默认规则

在文档中，`Make`的默认规则被称为“隐式规则”,现在我们已经理解了显式规则，让我们稍微研究一下隐式规则，看看如何调整它们。例如，将 C 文件转换成可执行文件的隐式规则如下所示:。

```
%: %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH) $^ $(LOADLIBES) $(LDLIBS) -o $@

```

(您可以通过运行`make -p`并查看产生的 1500 行来找到这一点。)

这里发生了很多事情，但是规则的基本格式是相同的:一个目标(%)依赖于一个 C 文件(或多个文件),然后有一个制表符缩进的规则说明如何到达那里。只有在这里，`%`是一个通配符，特殊变量`$^`和`$@`分别指依赖项和目标，您可能想要更改的所有内容都包含在所有大写的“隐式变量”名称中。

如果你真的尝试在 Windows 上运行第一部分的`makefile`less 版本，它可能会失败。为什么？因为我的 Windows 系统并不调用编译器“cc”——变量`CC`的默认值——而是“gcc”。我们可以通过为我们选择的编译器定义`CC`变量来解决这个问题。

此外，我喜欢在默认启用所有可能的编译器警告的情况下进行编译，给编译器传递`-Wall`标志。这正是`CFLAGS`变量的用途。为了总是在有警告的情况下编译，我们只需定义`CFLAGS=-Wall`就可以了。最后，定义隐式规则的方式支持多个 C 文件依赖关系，因此我们不妨在一个依赖关系语句中列出我们项目所需的所有文件。

我们改进的`makefile`，指定了一个特定的编译器，编译目标的两个依赖项，以及编译器警告标志，如下所示:

```
CC=gcc
CFLAGS=-Wall

hello: hello.c extras.c

```

注意，我们不需要为目标/依赖项指定一个规则，因为已经有一个隐含的规则匹配这个模式。因为`hello`目标是文件中的第一个显式目标，所以它是自动生成的，我们甚至不需要每次都键入“hello”。结果是我们可以简单地输入`make`，它就会运行`gcc -Wall hello.c extras.c -o hello`。

为了进一步定制，所有的[显式变量都记录在](https://www.gnu.org/software/make/manual/make.html#Implicit-Variables)中，所以如果你想知道一个选项是属于`LOADLIBES`还是`LDLIBS`，你可以通读这个列表。下一次我们将继续讨论这些内容，敬请关注。

## 越来越花哨

请注意我们只用一行三行代码`makefile`已经走了多远。已经向您介绍了隐式规则，并且了解了如何覆盖伴随它们的隐式变量来定制编译。

交叉编译和添加各种定制目标来驱动嵌入式编程工具链变得非常有趣。我们将在下一期讨论这些，并给出最少的 AVR 和 STM32 ARM Cortex `makefile`示例。我们的目标是保持同样的可读性，但正如阿尔伯特·爱因斯坦所说，我们的目标是“尽可能简单，但不简单。”

## Windows Postscript

如果你的 Windows 系统上还没有安装`make`，我已经成功安装了`mysys2`。[按照初始安装说明](http://msys2.github.io/)进行更新，然后`pacman --needed -Su base-devel mingw-w64-i686-toolchain`会给你一切你需要的东西`make`，并用 C、C++和其他一些语言编译。来自`mingw`包的控制台应用程序已经设置了所有正确的`PATH`变量，所以你只需输入`make`它就会运行。

如果任何人有一个最喜欢的或者简化的方法来获得一个编译器并且在 Windows 上运行，请在评论中发表。