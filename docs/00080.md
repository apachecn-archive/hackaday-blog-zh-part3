# 嵌入埃利奥特:中断，好…

> 原文：<https://hackaday.com/2015/09/18/embed-with-elliot-interrupts-the-good/>

为你的大型计算机和微控制器写代码的最大区别是什么？好吧，内存和有限的资源，当然。但是我们更多考虑的是直接与硬件接口的需求。出于这个目的，你的嵌入式工具箱中最有用的，当然也是最危险的工具之一就是中断。

中断就像它听起来做的那样——当事情发生时，它们中断程序操作的正常流程——并运行另一段代码(中断服务例程，或 ISR)。当 ISR 完成时，微控制器会从主流程中它停止的地方开始。

假设您将微控制器与一个加速度计相连，该加速度计有一个“数据就绪”引脚，当有新样本准备读取时，该引脚会被设为高电平。您可以将该引脚连接到微控制器上支持中断的输入端，编写一个 ISR 来处理加速度计数据，并配置微控制器的中断系统，使其在加速度计有新数据准备好时运行该代码。从那时起，所有与加速度计相关的事情都会自动发生！(理论上。)

这是三部分系列的第一部分:中断、好的、坏的和丑陋的。在本专栏中，我们将关注中断是如何工作的，以及如何最大限度地利用它们:好处。第二篇专栏文章将讨论重量级中断例程、优先级不匹配和主循环饥饿的危害:中断的负面影响。最后，我们将讨论一些在使用中断时可能突然出现的非常棘手的错误，主要是由于原子性的失败，这可能导致逻辑故障和损坏的数据；那当然是丑陋的。

## 中断好的一面

当各种事件发生时，中断允许微控制器启动特定的“子程序”。你可以在任何时候使用中断，只要你想让代码自动快速地对事件做出反应。各种外设，从加速度计到无线电，从 SD 卡到 GPS 模块，都需要一点时间来完成它们的工作。等待外设准备好(或完成)，然后采取行动，是一项非常重要的嵌入式编程任务，中断是我们最喜欢的处理这些外设生成的事件的方式，同时还能让 CPU 空闲下来做其他事情。

为了更清楚，让我们比较一下中断和其他选项。具体来说，想象一下，我们正在等待一个加速度计为我们提供一个新的数据样本。此外，假设加速度计将通过提高导线上的逻辑电压来发出信号，表明它获得了一个新样本。

一种可能是坐着等，直到就绪信号到来。这就是“阻塞等待”方法。

```

int main(void){
	while(1){
		do_stuff();
		while(line_is_low()){ /* wait here                */
			;                 /* doing nothing            */
		}                     /* until the line goes high */
		handle_new_data();
		carry_on();
	}
}

```

另一种可能性是继续做其他事情，但是只要有机会，就定期检查信号线的状态。这是“[轮询](https://en.wikipedia.org/wiki/Polling_(computer_science))”。

```

int main(void){
	while(1){
		do_stuff_repeatedly();
		if (line_is_high()){  /* ready yet? */
			handle_new_data();
		}
	}
}

```

最后，我们可以设置微控制器的中断处理程序，在线路变高时触发，并编写一个 ISR 来处理新数据。(初始化和 ISR 定义代码是特定于 AVR 的，但基本思想不是。)

```

ISR(INT0_vect){
	handle_new_data();
}

int main(void){

	EICRA |= (1&lt;&lt;INT0);                 /* enable individual interrupt             */
	sei();                              /* enable global interrupts                */

	while(1){
		always_do_stuff();
	}
}

```

正如你在中断代码中看到的，微控制器之间会有一些不同的额外配置负担，但之后在主`while`循环中就没有中断的迹象了。代码本身是在主代码之外定义的，也就是所谓的中断服务程序。ISR 何时运行一点都不明显；当它被触发时就会运行。

### 阻塞 v .轮询 v .中断

让我们比较一下这三种方法。阻塞对新信号的反应最快，但在信号到来之前，你的微处理器不能做任何其他事情。当绝对需要极快的响应时间时，这是一个合理的选择，但也只能如此。如果信号一直不来会怎么样？如果电线被拔掉或者外围设备的电池没电了？你的 CPU 没有更好的事情做吗？作为一个经验法则，除非你真的需要或者是一个非常懒的程序员在做一个要求不高的项目，否则不要阻塞。(谁，我们？！有时候。)

如果响应时间不重要，轮询信号线是可行的，因为注意到状态变化所需的时间取决于信号进入时代码在`do_stuff_continually()`函数中的位置。平均而言，响应时间将是到达`do_stuff_continually()`所需时间的一半，但最坏的情况是全部运行时间。

中断几乎结合了两个世界的优点而没有缺点。对输入信号的响应时间不会像阻塞等待代码那样迅速，但通常非常快:AVR 和 MSP430 大约需要 20 个时钟周期。(ARM Cortex 芯片致力于最大限度地减少和规范中断切换时间。)但是，最重要的是，在等待中断发生时，您的代码的其余部分可以正常执行。很少会有这样一个事件，它的时机如此关键，以至于不值得做任何事情来等待它，所以几乎所有时间都会中断节拍阻塞。

与轮询相比，中断的响应时间非常一致(通常在一个或两个周期内),并且比除了最琐碎的轮询情况之外的所有情况都要快。中断，如果在你的轮询代码中间被触发，将会优先处理。这意味着轮询最适合于不关心时间的低优先级任务。但是当然每个系统都有这样的任务。在轮询代码中，处理人类时间范围内(几十毫秒内)发生的事情通常是没问题的，它释放了您的中断来处理真正重要的事情。

总之:在时间和一致性很重要的地方使用中断，特别是在与其他机器通信的时候，并且不要犹豫去轮询那些不重要的事件。

### 引擎盖下:中断是如何工作的？

如果你要开始使用中断，有必要稍微了解一下它们在微控制器内部是如何实现的。它会让你对系统的深层行为有一些重要的了解。

每个可能触发中断的事件都有一个专用标志(特殊存储器寄存器中的一位)。大多数微控制器对于每个可能的中断向量都有一个使能位，此外还有一个全局中断使能标志，可以一次覆盖所有的中断。当一个事件发生时，它的标志被设置。如果对应于该事件的特定中断使能标志和全局中断使能标志都已置位，那么中断就可以运行了！如果这三个条件中的任何一个失败了，自然地，什么都不会发生。

注意，这个系统意味着如果一个事件已经发生，并且它的标志被置位，当全局和特定使能位被置位时，该中断将立即触发。作为这个条件的推论，假设您已经启用了一系列特定的中断，但是禁用了全局中断位。例如，如果您不希望中断被中断，那么在处理 ISR 时就会发生这种情况。无论如何，当你最终再次设置全局中断使能时，许多事件已经发生了。现在，机器正在处理许多中断。它先选择哪个？

当任意数量的中断同时触发时，AVR 和 MSP430 微控制器有一个简单的固定优先级系统。例如，在 AVR 上，外部引脚中断的优先级高于定时器/计数器，然后是 USART(串行端口)。每一个都是依次处理的，当第一个完成时，就转移到下一个最高优先级。如果更高优先级的中断同时发生，这些中断会在下一次处理。如果有必要，您可以在数据手册中查找优先级。

在 ARM 系统上，优先级系统要复杂得多。[嵌套向量中断](http://stm32f4-discovery.com/2014/05/stm32f4-stm32f429-nvic-or-nested-vector-interrupt-controller/)有两组优先级，每组都可以分配给任何中断事件。顶层控制哪些中断可以相互中断，而底层从给定的顶层优先级组中选择哪个中断先被执行。您可以用它创建的嵌套优先级系统非常令人兴奋，远远超出了本文的范围。我只想说，如果你在一个系统上有两个 USART，你想让其中一个 USART 中断 SPI ISR，而不是另一个 USART，*和*你想让 USART0 总是在 USART1 之前得到处理，你可以做到这一点。

最后，在 AVR 或 MSP430 上，每个可能的中断在代码内存中都有一个固定的位置，当该中断被触发时，它会在该位置查找要运行的指令。这些位置中的每一个都包含一个带有地址的跳转命令:你希望与中断相关联的例程的内存地址。默认情况下，这个跳转表(链接)由不去任何地方或返回芯片到其刚刚复位状态的命令填充。但是通过把你想调用的一些代码的地址放在内存中正确的位置，当中断被触发时，芯片将开始执行这些代码。

### 其他愚蠢的中断技巧

在结束“良好”中断部分之前，我们不能不提到两种特殊的中断模式，这两种模式几乎在每个 AVR 微控制器项目中都会用到。

大多数微控制器有一个或两个或三个定时器/计数器类型的外设。这些只是以给定的速度向上计数，与 CPU 无关。将中断配置为当计数器溢出或达到某个值时触发，然后在 ISR 中增加一个全局“系统时钟”变量，这提供了一个非常方便的可变时基，如果您愿意，可以将其减慢到接近人类的时间尺度。例如，这就是 Arduino 对`millis()`所做的。(比如 ST 的 ARM 芯片，有专门的系统滴答时钟，超级性感。)

对于 AVR，将计数器配置为系统滴答时钟可能非常简单:

```

volatile uint16_t ticks;

ISR(TIMER0_OVF_vect){
	++ticks;
}

void initTicks(void){
	TCCR0B |= ((1&lt;&lt;CS02) | (1&lt;&lt;CS00)); /* set largest clock divisor */
	TIMSK0 |= ((1&lt;&lt;TOIE0)); /* enable overflow interrupt */
	sei(); /* enable global interrupts */
}
```

(处理`ticks`变量并不完全简单，我们将在“丑陋的”一期中解释为什么会这样。)

中断也是将微控制器从省电睡眠模式中唤醒的好方法。当 CPU 不做任何事情时，您可以通过关闭 CPU 时钟并让系统进入睡眠状态，将其功耗降至区区几微安(对于 MSP430，甚至是几微安的几分之一)。但是当事情发生时，你如何唤醒芯片呢？当然是中断。

同样，在 AVR 上，您甚至可以定义空的 ISR，这些 ISR 不做任何事情，而是明确地用于从睡眠模式返回的目的。

```

EMPTY_INTERRUPT(INT0_vect);         /* instead of ISR()                */

void sleep(void){
	EIMSK |= (1 &lt;&lt; INT0);           /* set individual interrupt enable */
	sei();                          /* enable global interrupts        */
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);
	sleep_mode();                   /* now to sleep                    */
}

```

上面的`sleep()`函数确保单个中断和全局中断位都被置位，告诉处理器进入哪种睡眠模式，然后关闭。当按下外部按钮(连接到 INT0)时，调用无所事事的 ISR，芯片唤醒，程序流程返回到调用`sleep()`后的命令。

## 结论

现在你知道了。中断对于响应外部设备、创建时基、将芯片从省电模式中唤醒等等非常有用。我们希望了解中断是如何工作的，以及它们有什么好处，这将帮助你更像微控制器一样思考，并找到将它们放入项目的正确位置。

处理中断使代码流脱离了线性的、一个函数接一个函数的主循环。这带来了调度问题和一些严重的潜在故障，这些将是下两个专栏的主题，我们将讨论使用中断的不好和不好的一面。请继续关注，并在评论中告诉我们你的想法。