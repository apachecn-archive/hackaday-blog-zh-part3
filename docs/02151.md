# 嵌入埃利奥特:保持其完整性

> 原文:[https://hack aday . com/2016/04/22/embed-with-Elliot-keeping-it-integral/](https://hackaday.com/2016/04/22/embed-with-elliot-keeping-it-integral/)

如果有一件事是许多小型微控制器讨厌的(包括基于 AVR 的 Arduini)，那就是浮点数。如果还有什么他们讨厌的，那就是组织。例如，在 Arduino UNO 上，将 72.3 除以 12.9 需要大约 32 微秒和 500 字节，而将 72 除以 13 需要 14 微秒和 86 字节。72 乘以 12 需要不到 2.2 微秒的时间。所以粗略来说，除浮点数比除(16 位)整数慢一倍，根本除比乘法慢五到七倍。

很多时候你根本不在乎速度。例如，如果你正在做一个不经常运行的计算，不管你是使用浮点还是慢速除法例程。但是如果你发现自己处于一个使用浮点数学和/或做除法的死循环中，并且你需要获得更快的速度，我有一些提示给你。

其中一些技巧(尤其是最后的整数除法技巧)是神秘的魔法——只有在真正需要的时候才使用。但是，如果你在重复做同样的计算，只要以微控制器本身能理解的格式给出数字，你就能获得很多。有点同情被困在里面的可怜的小硅兽吧！

## 浮动回避

只要稍微思考一下，就可以完全避免浮点数。仅仅看到一个带小数位的数字并不是去掉浮点数的理由。例如，如果你有一个量，像 LM75 型温度传感器上的温度，精确到 1/8 度，你绝对不需要浮点数。21.125 度没有浮子怎么处理？与 LM75 完全相同，它将所有内容预先乘以 8。

避免浮点数通常就像找出问题的自然单位一样简单。是 12.34 美元还是 1234 美分？我只能用手锯精确地切割到大约一毫米。如果我用毫米来测量木板的长度，我就永远不需要小数点了。当然，数字越来越大，这意味着你可能需要使用下一个最大的整数存储大小，但微控制器并不介意浮点数学。

因此，如果您从一个 10 位 ADC 获取读数，并且其范围为 3.3V，那么您最不想做的事情就是在测量后将其直接转换为伏特数(即使这可能会让您的代码读起来更好)。)保留 ADC 值——它是一个很好的 10 位整数——只有在完成所有其他数学运算后，在绝对需要时才转换为实际电压。当你这样做的时候，注意你的问题的正确单位是最小可能测量差，即 3.3 V / 1023 = 3.23 毫伏。当您需要为最终用户转换到物理单位时，您将乘以这个值。

每当遇到分数或浮点数时，尝试重新定义度量单位。你会惊讶地发现，一开始你并不需要它们。这里有一个警告:在转换回想要的单位时要小心。一平方厘米不是 10 平方毫米，是 100。转换中的每一个“毫米”都会带来 10 的幂次。而十毫米除以一毫米正好是十，没有单位剩下，也不需要换算。

### 定点数学

![FixedPointNumbers](../Images/7d86e8e26b86e4e2b894e27b1ac9370b.png)

虽然简单地摆脱较慢的 float 类型在某些情况下足以加速，但如果您需要的话，还有一个额外的优化层可用。例如，在小型微控制器上，常见的选择是简单地将所有值乘以 256。这被称为“8:8 定点”符号，因为小数部分使用 8 位，整数部分使用 8 位。

事实证明，如果您知道小数部分的位数，您可以优化乘法和除法，使其运行速度比 16 位乘法或除法更快。例如，这里有一篇关于 Arduino 的定点数学选项的精彩文章。你可以在[这篇 Atmel 应用笔记](http://www.atmel.com/dyn/resources/prod_documents/DOC1631.PDF)中阅读这些优化。请注意，算法并不特定于任何平台。

因此，当你不需要任意分数时，定点库比使用浮点例程要快得多。

## 反正浮点数也很糟糕

浮点数有一个众所周知的问题:在测试它们是否相等时，你必须非常小心。那是因为它们都没有被精确地表示出来。例如，0.1 不能精确地用浮点表示，所以如果你把 10 个加起来，也不会精确到 1.0。如果你要测试`sum10(0.1) == 1.0`,结果会是假的。太糟糕了。

浮点数的另一个特别之处在于它们的构造方式。浮点数就像科学记数法(1.23 x 10 ³ ，除了二进制。[大多数编译器遵循的 IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) ，使用 24 位作为第一个数字——有效位数——和 7 位作为指数。这让你可以表示非常大和非常小的数字。但是因为到处都有相同数量的有效数字，所以可表示数字之间的差距对于小数字来说是非常小的，并且随着指数中每个 2 的幂而加倍。

例如，`123456789.0 + 1.0 == 123456789.0`将为真，因为 24 位有效数字之间的间距大于 1。如果使用整数，则`123456789 + 1 == 123456789`将为 false，因为整数之间的间距始终恰好为 1。

简而言之，整数是精确的，它们在整个范围内保持可表示值之间的相同距离。我发现这通常非常符合我在微控制器项目中使用的输入和输出类型。另一方面，浮点数的范围要大得多，但这样做的代价是可能值之间的距离越来越大。当浮点数不能精确地表示数字时，比较也不能精确地进行。

## 不快乐的分裂

大多数低端微控制器(同样，包括 Arduino 中使用的 AVR)没有内置硬件部门。这意味着他们将使用某种迭代算法来寻找答案。这需要一段时间。有一个很好的捷径，至少对于整数来说，你应该知道。在二进制中，除以 2 的`n`次方等同于去掉数字的最低有效位`n`。`x >> 2`移位`x`两个位置，实际上除以 4。就像用十进制除以十一样。去掉最后一个数字。

AVR-GCC 为您优化了这种移位除法(及其对偶乘法),因此您实际上不必考虑它。但最终会出现奇怪的情况，即`x/4`运行得非常快，而`x/5`可能需要更长一点的时间。如果你可以选择你的约数，你应该总是选择它们是 2 的幂。如果你要将 10 个值平均在一起，如果你只使用 8 个观察值，你的算法会运行得更快，如果你使用 16 个观察值，你的算法也不会差很多。

## 整数除法技巧

![Image: minifigure.org](../Images/c59f3337efa431446bc4693288443620.png)

Image: [minifigure.org](http://www.minifigure.org/2011/05/wizard/)

这最终把我们带到了承诺的黑暗魔法——当你需要快速划分整数时，你可以使用两个讨厌的技巧。主要的警告是，这些技术只有在除数恒定时才有效。你必须提前知道它是什么才能使用它。但是当你需要一遍又一遍地除以 13 时，这里有两种方法可以让你尽快地达到目的。

### 乘然后除

这里的基本思想是将除法预先计算为乘法和位移。用同样的方法，您可以先乘以 5 再除以 2，然后删除最低有效位(实际上是除以 10)，您可以预先计算二进制乘数和要删除的位数。这个想法是道格拉斯·琼斯在这篇文章中提出的[，然后](http://homepage.cs.uiowa.edu/~jones/bcd/divide.html)[在这里编码](http://codereview.blogspot.com/2009/06/division-of-integers-by-constants.html)。

特别是，要将任何 8 位数字除以 13，首先要将该数字乘以 158(得到 16 位整数)，然后去掉最低有效的 11 位。是啊，对吧？之所以有效是因为`158/2^(11) ~= 1/13`。这只是数学，它将尽可能快地运行，但它不是完全可读的。

### 查找表

如果你真的，绝对需要快速除以 13，有一种方法比上面的技巧更快:预先计算所有可能的值，并将它们存储在一个数组中。例如，对于 8 位数字，创建一个包含所有可能的 256 个值除以 13 的表。我们就叫它`thirteen_table[]`。然后当你需要超级快地知道什么是`123 / 13`的时候，只要查一下`thirteen_table[123]`就大功告成了。这是欺骗，它使用 256 字节的内存，但如果这个技巧让你摆脱了棘手的情况，它是值得知道的。

## 过早优化

Donald Knuth 有一句名言:“过早优化是万恶之源”。基本的论点是，如果你总是以最大的速度为目标来编写你的除法程序，你可能最终会得到一堆不可读的代码，却没有什么好处。也许花费您的优化时间的正确地方是确保两个不同的子系统可以并发运行，或者其他事情。

因此，对以上所有内容要有所保留。如果您没有硬件浮点数学，仔细考虑您的单元，并弄清楚是否有可能将它们重新转换为整数可能总是一个好主意。如果你已经在使用整数，把任意约数换成 2 的幂也是一个不错的选择。

无论您是想进入定点库的下一步，还是能够使用快速除以常数的卑鄙手段，都取决于您的情况和需求。如果它使你的代码变得过于复杂，并且 CPU 有很多空闲时间，或者如果它在一个非时间关键的部分，不要打扰。

我们还应该知道哪些肮脏的数学把戏？你最喜欢或最讨厌的是什么？整数 vs .浮点？请在评论中告诉我们！