# 34C3:侵入 CPU 的微码

> 原文:[https://hack aday . com/2017/12/28/34 C3-hacking-into-a-CPU-microcode/](https://hackaday.com/2017/12/28/34c3-hacking-into-a-cpus-microcode/)

自从 Intel Pentium `fdiv` bug 以来，在每一个现代 CPU 内部，汇编指令并不是 CPU 实际功能的一对一映射。在 CPU 内部，有一个解码器将汇编转换成更原始的指令，这些指令被送入 CPU 的内部调度程序和流水线。驱动解码器的代码是 CPU 的*微码*，它存在于通常不可访问的 ROM 中。但是过去已经部署了微码补丁来修复 CPU 硬件错误，所以它肯定是可写的。这实际上是一个邀请，对不对？至少鲁尔大学波鸿分校的一个小组是这样认为的，并且[开始破解 AMD K8 和 K10 处理器中的微码](https://media.ccc.de/v/34c3-9058-everything_you_want_to_know_about_x86_microcode_but_might_have_been_afraid_to_ask)。

使用微码的障碍令人望而生畏。它把汇编语言变成了某种东西，但内部 CPU、ALU 等使用的指令集却完全不为人知。[Philip]向我们介绍了他们的第一道攻击线，基本上是在黑暗中猜测。首先，他们绘制出每个 x86 汇编代码在微码 ROM 中的位置。利用这些信息以及更新微码的能力，他们可以加载并执行任意微码。他们仍然对微码一无所知，但他们知道如何运行它。

所以他们开始上传随机微码，看看它做了什么。这个随机微码几乎每次都崩溃。其余时间，输入和输出状态没有区别。但是，经过一周的运行，一个突破:微码异或。由此，他们找出了命令的语法，并开始通过试错发现更多的命令。在游戏的后期，他们继续把芯片拆开，用显微镜和 OCR 软件读出 ROM 中的内容，至少足以验证一些微码操作是在 ROM 中烧录的。

结果是 29 个微码操作，包括逻辑、算术、加载和存储命令——足以开始编写微码代码。第一批微码程序的编写自然有助于进一步的发现。但不久之后，他们编写了微码后门程序，当一个给定的计算被执行时就会触发，并编写了隐形木马程序，通过在计算中以编程方式引入错误来泄漏加密或“不可检测”的数据。这意味着几乎检测不到驻留在 CPU 内部的恶意软件。(你认为[英特尔管理引擎黑客](https://hackaday.com/2017/12/11/what-you-need-to-know-about-the-intel-management-engine/)让你变得偏执！)

[![](../Images/35102475e31c5d0d67553a403cdc5d32.png)](https://hackaday.com/wp-content/uploads/2017/12/microcodemp4download-shot0007_thumbnail.png) 【本杰明】然后勇敢地带领我们通过基于浏览器的攻击现场，首先在调试器中，我们可以验证他们的自定义微码被触发，然后在调试器外，突然弹出`xcalc`。是什么启动了这个项目？从未经修改的浏览器内部计算网站上的特定数字。

他还演示了在微码中引入一个简单的数学错误，当另一个特定的乘法运算完成时，这个错误会使加密程序失败。虽然这听起来可能不多，但如果您注意了基于单个不常见的位错误揭示密钥的谈话，您会发现这实际上是几百万倍的强大，因为错误每次都会发生。

该团队还没有完成他们的微码探索，仍然有更多的命令集有待发现。因此，将此作为一个概念证明，几乎完全检测不到的特洛伊木马可能存在于编译代码和计算机 CPU 之间运行的微码中。但是，更有趣的是，这也是一个开始探索自我的邀请。计算机黑客攻击的全新领域并不是每天都有。