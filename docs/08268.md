# 幽灵党和熔毁:缓存如何工作

> 原文:[https://hack aday . com/2018/01/15/spectre-and-meltdown-how-cache-works/](https://hackaday.com/2018/01/15/spectre-and-meltdown-how-cache-works/)

到目前为止，这一年充斥着幽灵和崩溃的消息。这些漏洞利用了推测性执行和内存访问计时等特性。它们的共同点是，所有现代处理器都使用缓存来更快地访问内存。我们都听说过缓存，但它到底是什么，它是如何让我们的计算机运行得更快的？

最简单地说，高速缓存是一种快速内存。计算机有两个存储系统:主存储(RAM)和辅助存储(硬盘，SSD)。从处理器的角度来看，从 RAM 加载数据或指令很慢——在加载数据时，CPU 必须等待 100 个周期或更长时间，什么也不做。从磁盘加载更慢；浪费了数百万个周期。高速缓存是少量非常快速的内存，用于保存经常访问的数据和指令。这意味着处理器只需等待缓存加载一次。之后，无需等待即可访问数据。

缓存的一个常见类比(尽管已经过时)是用书来表示数据:如果您需要某本书来查找某条重要信息，您将首先检查您桌子上的书(缓存)。如果你的书不在那里，你可以去你书架上的书(RAM)。如果搜索结果是空的，你会去当地的图书馆(硬盘)去借这本书。一旦回家，你会把书放在桌子上快速查阅，而不是马上把它放回图书馆的书架上。这就是缓存读取的工作原理。

![](../Images/052dd672945e19a6c64c0391917144aa.png)

Intel Haswell diagram. Note how much real estate is used by the L3 cache and the Memory Controller.

### 缓存是昂贵的不动产

早期的计算机运行速度很慢，缓存真的无关紧要。当 CPU 速度以千赫兹来衡量时，核心内存已经足够快了。第一个数据高速缓存用于 1968 年发布的 IBM System/360 Model 85。IBM 的文档声称，与没有数据缓存的系统相比，内存操作花费在⅓上的时间更少。

现在显而易见的问题是，如果缓存更快，为什么不把所有内存都从缓存中取出来呢？对此有两个答案。首先，缓存比主存贵。一般缓存都是用静态 ram 搭建的，比主存用的动态 ram 贵很多。第二个答案是位置，位置，位置。随着处理器以几 GHz 的速度运行，高速缓存现在需要与处理器本身在同一块硅片上。通过 PCB 走线发送信号需要很长时间。

CPU 内核一般不知道也不关心缓存。所有内务处理和缓存管理都由内存管理单元(MMU)或缓存控制器处理。这些是复杂的逻辑系统，需要快速运行以保持 CPU 加载数据和指令。

### 直接映射缓存

最简单的缓存形式被称为直接映射缓存。直接映射意味着每个内存位置只映射到一个缓存位置。在该图中，有 4 个缓存片段。这意味着缓存索引 0 可能包含内存索引 0、4、8 等等。由于一个缓存块可以保存多个内存位置中的任何一个，缓存控制器需要一种方法来知道哪个内存实际上在缓存中。为了处理这个问题，每个缓存块都有一个标签，用来保存当前存储在缓存中的内存地址的高位。

缓存控制器还需要知道缓存实际上保存的是可用数据还是垃圾。当处理器第一次启动时，所有的高速缓存位置都是随机的。如果这些随机数据中的一些被意外地用在计算中，那就真的很糟糕了。这是用有效位来处理的。如果有效位设置为 0，则缓存位置包含无效数据并被忽略。如果该位为 1，则缓存数据有效，缓存控制器将使用它。在处理器加电时，有效位被强制为零，并且每当高速缓存控制器需要使高速缓存无效时，该有效位可以被清除。

### 写入缓存

到目前为止，我已经介绍了使用缓存的读访问，但是写访问呢？高速缓存控制器需要确保在高速缓存被一些新的内存访问覆盖之前，对高速缓存中的内存所做的任何更改也在 RAM 中进行。有两种基本方法可以做到这一点。首先是每次写入缓存时都要写入内存。这就是所谓的直写缓存。直写是安全的，但会带来速度损失。读取速度很快，但写入速度较慢。更流行的系统叫做回写缓存。在写回系统中，改变被存储在高速缓存中，直到该高速缓存位置将要被覆盖。缓存控制器需要知道这种情况是否已经发生，因此在缓存中增加了一个称为脏位的位。

缓存数据需要所有这些内务数据—标签、有效位、脏位—存储在高速缓存中，这增加了缓存系统的总体成本。

### 关联缓存

直接映射的高速缓存将加速存储器访问，但是存储器到高速缓存的一对一映射相对低效。允许数据和指令存储在多个位置会更有效。

完全关联的高速缓存正好允许这样做——任何内存位置都可以存储在任何高速缓存位置。这也意味着每次访问内存时都必须搜索缓存。像这样的搜索功能是用硬件比较器完成的。像这样的比较器需要很多逻辑门，并占用芯片上很大的物理面积。快乐媒介是一个集合关联缓存。该图示出了 2 路组关联高速缓存。这意味着任何内存位置都可以放入两个缓存位置中的一个。这使得硬件比较器相对简单和快速。例如，英特尔酷睿 i7-8700K 三级高速缓存是 16 路组关联的。

### 虚拟内存

起初，计算机一次运行一个程序。程序员可以访问系统的整个内存，并且必须管理如何使用这些内存。如果他或她的程序比系统的整个 ram 空间大，程序员就可以根据需要换入或换出程序段。想象一下，每次你想打印一些东西的时候，你必须检查 printf()是否被加载到内存中。

虚拟内存是操作系统直接与处理器 MMU 一起处理这个问题的方式。主存被分成几页。每一页都在需要时被换入。如今内存价格低廉，我们不必太担心换出到磁盘。然而，虚拟内存仍然非常重要，因为它提供了一些其他的优势。

虚拟内存允许操作系统同时运行许多程序——每个程序都有自己的虚拟地址空间，然后映射到物理内存中的页面。这个映射存储在页表中，而页表本身位于 RAM 中。页表非常重要，它有自己的特殊缓存，称为翻译后备缓冲区，或 TLB。

MMU 和虚拟内存硬件还与操作系统一起执行内存保护——不要让程序读取或修改彼此的内存空间，也不要让任何人搞乱内核。这是被幽灵和熔毁攻击回避的保护。

### 进入现实世界

如您所见，即使相对简单的缓存系统也很难跟上。[在像英特尔 i7-8700K 这样的现代处理器中，有多层高速缓存](http://www.cpu-world.com/CPUs/Core_i7/Intel-Core%20i7%20i7-8700K.html)，有些是独立的，有些在 CPU 内核之间共享。还有推测性执行引擎，它在给定内核准备好使用数据之前，就将可能使用的数据从内存中提取到缓存中。那个引擎是熔毁的关键。

Spectre 和 Meltdown 都在基于时间的攻击中使用缓存。由于缓存内存的访问速度要快得多，攻击者可以通过测量访问时间来确定内存是来自 RAM 还是缓存。该定时信息然后可以用于实际读出存储器中的数据。这就是为什么两周前浏览器推出了一个 Javascript 补丁。该补丁[使得内置的 Javascript 计时功能稍微不太准确](https://hackaday.com/2018/01/06/lowering-javascript-timer-resolution-thwarts-meltdown-and-spectre/)，足以使它们在测量内存访问时间方面毫无价值，这可以防止基于浏览器的对这些漏洞的利用。

试图缓解 Spectre 和 Meltdown 的简单下意识方法是禁用缓存。与我们习惯的速度相比，这将使我们的计算机系统慢得令人难以置信。正在推出的补丁远没有达到这种程度，但它们确实改变了 CPU 使用缓存的方式——特别是在用户空间到内核空间的上下文切换上。

现代 CPU 数据路径和高速缓存设计是一项极其复杂的任务。处理器制造商通过模拟和统计分析处理器如何移动数据以使系统既快速又可靠，积累了多年的数据。只有在绝对必要的时候，并且只有在经过数千小时的测试之后，才会对处理器微码之类的东西进行更改。像当前的英特尔和 AMD 补丁这样匆忙(是的，六个月是匆忙)做出的散弹枪式的改变肯定会有一些问题——这正是我们看到的重大性能打击和崩溃。修复的软件方面，如[内核页表隔离](https://en.wikipedia.org/wiki/Kernel_page-table_isolation)可以强制刷新 [TLB](https://en.wikipedia.org/wiki/Translation_lookaside_buffer) ，这也会对频繁调用操作系统的应用程序的性能造成严重影响。这解释了为什么变化的影响如此依赖于应用程序的一些原因。本质上，我们都是 beta 测试者。

不过也有好的一面。希望芯片制造商和软件供应商有更多的时间进行研究和测试，更好地理解必要的变化，并发布更好的补丁。

也就是说，直到找到下一个攻击媒介。