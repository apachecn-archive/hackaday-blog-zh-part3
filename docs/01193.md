# 利用 FPGAs 加快排序速度

> 原文:[https://hack aday . com/2016/01/20/a-linear-time-sorting-algorithm-for-FPGA/](https://hackaday.com/2016/01/20/a-linear-time-sorting-algorithm-for-fpgas/)

分类。这是一个已经研究了几十年的经典问题，也是迈向“用算法思考”的伟大的第一步多年来，出现了一些排序算法，每种算法都可以通过其 *[渐近顺序](https://en.wikipedia.org/wiki/Big_O_notation)* 来表征，这是一种随着问题规模变大而衡量算法需要多长时间的方法。虽然所有排序算法都需要较长时间来完成更多必须排序的元素，但有些算法比其他算法慢。

对于像*冒泡分类*这样的分类器来说，输入数量线性增加，时间以平方增长；这是命令。有了像*合并-排序*这样更快的排序器，也就是`O(N*log(N))`，随着问题规模变大，所需的时间增长得更慢。由于排序在这里的许多人看来有点过时，而且由于`O(N*log(N))`似乎是普遍接受的单核最高速度的基线，我想我应该提出这个问题:我们能更快吗？

简而言之，是的，我们可以！事实上，我会说我们可以按线性时间排序，即运行时间为`O(N)`。不过，有一个问题:为了实现线性时间，我们需要构建一些定制的硬件来帮助我们。在这篇文章中，我将展开并行排序的问题，然后我将带我们通过一个线性时间的解决方案，我们可以在家里的 FPGA 上合成。

需要开门见山吗？在 GitHub 上查看在 SystemVerilog 中实现的完整解决方案。我将它封装在 SPI 通信层中，这样我们就可以使用日常的微控制器来玩它。

要了解它的工作原理，请加入我们，开始硬件算法设计之旅。如果你习惯于以一种循序渐进的方式为 CPU 编程，那么是时候摆脱你的思维定势了！

## 平行的方法

我们的目标是提供一个数字逻辑模块，它串行接收数据，或者每个时钟周期一次，并对数据进行排序。为了实现线性时间基准，我选择在数据进入时对数据*进行排序。从这个意义上说，一旦我们完成了数据的输入，我们的数组应该立即排序，准备再次输出。*

如果我们可以构造这样的块，那么我们的硬件解决方案就是线性的，或者说`O(N)`。这个问题可能看起来很复杂，但解决方案实际上相当简单——前提是我们并行进行排序。为了解释这个算法是如何工作的，让我们看一个简单的例子:对一个三元素数组进行排序。

### 示例时间:三分类器

让我们从一个简单的例子开始，将一个三元素数组排序到一个大小为 3 的容器中。

![3-sorter](../Images/f734951033287e6df3969fcfda3ffaa4.png)

在左边，我们已经准备好了未排序的列表，可以按顺序输入；右边是我们的“三分类器”分类单元，单元阵列的大小为 3。(An *e* 表示单元格为空。)在三排序器内部，我将声明这个单元格数组中的元素从上到下是以递增的大小存储的。我们的目标是根据当前单元格数组中的内容，将每个新元素放在正确的位置。在这一点上，我们实际上并不知道使这种排序发生的信号的任何细节，但我们将遍历数据流并在之后建立逻辑。

#### 排序步骤 1:

![insert_step_1_simple](../Images/a410856f744fa845f6a3516d2c8033c2.png)

在步骤 1 中，所有单元格都是空的。我们从插入一个新元素开始，但是我们需要一个地方来放置它。因为所有的单元格都是空的，所以这个新元素是我们到目前为止看到的最小的元素，所以让我们把它插入到顶部。即使只有一个元素，我也要大胆地声明我们的单元格数组是有序的。

#### 排序步骤 2:

![insert_step_2_simple](../Images/5973c76cfcc8f06a7b622d551c741c83.png)

在步骤 2 中，我们尝试插入第二个元素。我们的第一个问题可能是:这个元素在当前容器中的什么位置？查看所有单元，我们可以看到这个第二元素 *4* 大于所有其他被占用单元中的元素。 *4* 可以放入 *3* 之后的任何一个空槽中，但是我们会把它放在最后一个被占用的槽之后的第一个空槽*中。因此，我们的新数组仍然是有序的。*

#### 排序步骤 3:

![insert_step_3_simple](../Images/e6cd71e6b3806b2b93321f1489cf1a4d.png)

在步骤 3 中，我们将插入第三个元素， *3* 。查看我们的细胞容器，我们知道 *3* 正好放在 *2* 和 *4* 之间，但是根本没有空的空间。为了腾出空间，我们将把 *4* 向下踢到下一个单元格，并将 *3* 放在 *4* 的旧位置。(抱歉， *4* ，但这是为了科学！)现在我们已经插入了*3*——猜猜怎么着——我们的内部单元格仍然是排序的！

退一步说，每当我们插入一个新元素，我们看着每个单元格并问自己:“我的新数据适合这里吗？”因为我们事先已经同意我们的单元格数组的内容将总是被排序，结果是每个单元格都可以独立地回答这个问题，而不需要知道其余单元格的内容。它所需要做的就是从它上面的细胞中获取一些信息。

唉，要是这些细胞足够“聪明”，能够自己行动，并对自己的数据和邻居的数据提出问题就好了。如果可以的话，那么我认为所有的细胞都可以独立地同意，当每个元素开始计时时，谁来持有新元素。

### 并行分类的信号

既然我们已经看到了细胞分类的实际操作，让我们再来看一下这个例子，同时深入了解这些细胞是如何交流的。在不知道其余单元格的内容的情况下，所有单元格都需要独立地同意新元素放在哪里，以便我们的新元素只存储一次。让我们来看看这种“细胞语言”的实际应用。

#### 详细分类步骤 1:

![insert_step_1_detailled](../Images/67f6f276ebe2d3886d32fffea4d1e87d.png)

在步骤 1 中，我们从插入 *2* 开始。在这里，所有的细胞都是空的，所以任何地方都是公平的游戏。由于 *2* 是我们迄今为止看到的最小元素，它需要放在顶部的单元格中。顶部的单元还需要一种方式来告诉所有其他单元，它刚刚得到了即将到来的 *2* 的优先权。我们不希望有一个“细胞声称”的信号，传播所有的方式链；那太慢了。相反，我们将在所有细胞间达成协议。如果一个单元格是空的，那么如果它上面的相邻单元格被占用，它将只*要求进入的元素。现在，当新数据到达时，每个空单元只需要向上看它上面的单元，以查看该单元是否被占用。如果是，则该空单元格声明新数据。如果不是，那么我们假设它上面的某个空单元格已经有了。为了引导第一个单元总是声明一个传入数组的第一个元素，我们将硬连接它的“高于单元被占用”信号为真。(就是上图中假的灰色单元格。)*

我们刚刚达成的这个“交易”需要非常严格，我们称之为“规则 1”

*   ***规则一:*** *如果一个单元格为空，那么只有当上面的单元格不为空时，它才会认领进来的元素。*

#### 详细分类步骤 2:

![insert_step_2_detailed](../Images/93553f211ec44e8752bb4cc822d560a4.png)

在步骤 2 中，第二个元素 *4* 将被排序。这里我们知道 *4* 应该去追 *2* ，但是我们的细胞是怎么知道的呢？如果一个单元被占用，它需要问这样一个问题:“这个传入的新号码是否小于我当前的号码？”如果是，那么该单元将踢出它的当前号码并用新号码替换它。当前的数字可能会被踢到它下面的下一个单元格。嗯，如果每个被占用的单元都问同样的问题，那么可能会有多个单元非常乐意用新的号码替换它们当前的号码。如果这是真的，那么我们就冒着存储一个输入元素的多个副本的风险。我们不能这样，所以我们要制定另一个规则。

*   ***规则二:*** *如果一个单元格被占用了，如果进来的元素小于存储的元素，并且这个单元格上面被占用的单元格没有踢出它的元素，那么它就会认领进来的元素。*

唷！现在，整个单元格数组中只存储了传入元素的一个副本。

为了确保我们不会在单元格删除数据时丢失数据，我们将制定另一个规则。

*   ***规则三:*** *如果当前单元格上面的单元格逐出了它存储的元素，那么当前单元格必须声明上面单元格的元素，不管当前单元格是空的还是被占用的。*

如果一个单元格是空的，它将遵循“规则 1”和“规则 3”

#### 详细分类步骤 3:

![insert_step_3_detailed](../Images/dc07c02df78b017ea5c765e4a0c05349.png)

现在，让我们像上一个例子一样尝试插入一个 *3* 。 *3* 应该很适合 *4* 的位置，但是我们的细胞怎么知道呢？顶部的单元格中有一个 *2* ，因为二小于三，所以 *2* 保持不变。然而，第二个单元格持有一个 *4* ，由于 3 小于 4， *4* 得到引导，需要向下移动一个单元格。第一个空单元格可以获取新数据，因为它是空的，但是由于 *4* 刚刚被上面的单元格踢出，这个空单元格取而代之的是 *4* 。下面所有其他空单元格都遵循“规则 1”。这些单元格中的每一个都是空的，这些单元格上面的每个单元格当时也是空的，所以它们一直是空的。

我们将为声明新数据的单元格制定最后一条规则:

*   ***规则四:*** *如果一个单元格被占用，接受了一个新元素(要么来自上面的单元格，要么来自传入的数据)，就必须踢出它当前的元素。*

使用我们所有的其他规则，我们可以保证任何被踢出的元素都将被下面的单元格捕获。

如果我们所有的单元格都遵循这些规则，那么我们可以保证，它们可以一起对数组进行排序，而不需要知道所有其他单元格的单元格内容，因为这对于单元格数组结构是隐式的。也就是说，每一个排序步骤都很快，在每个时钟周期都会出现 *N* 个相同且独立的问题。

### 看——一个分类单元

既然我们已经理清了规则，让我们来看一下单个排序单元的解剖，每个排序单元构成了我们的单元数组中的一个单元。

![sorting_cell](../Images/43eec339cefad01688db2196966c6ee3.png)

为了遵循我们刚刚生成的规则，每个单元需要知道关于它的上游单元的信息，并传递关于它的当前状态和数据的信息。简而言之，这些信号只是成为内部数字逻辑集合的输入和输出。为了“遵守”我们架构的规则，我们需要求助于时序逻辑和组合逻辑的一小部分。

首先，每个单元需要跟踪自己的状态，*空*或*被占*。在 SystemVerilog 中，我们可以将这个特性实现为双态状态机。为了确定我们是否会要求新数据、以前的数据，或者保留当前的数据，我们需要遵循规则，我已经将这些规则总结为组合逻辑的一个模块。

首先，我们需要一些中间信号:

```

assign new_data_fits = (new_data &lt; cell_data) || (cell_state == EMPTY);
assign cell_data_is_pushed = new_data_fits &amp; (cell_state == OCCUPIED);

```

`new_data_fits`只是我们判断一个单元格是否能容纳新数据的标准。

`cell_data_is_pushed`告诉我们被占用的单元格中的当前单元格数据是否被踢出到较低的级别。

现在，我们可以把排序单元的真正细节放在一起:决定存储什么数据的逻辑。

```

if (reset)
    begin
        cell_data &lt;= 'b0; // actual reset value is irrelevant since cell is empty
    end
    else if (enable)
    begin
//{shift_up, new_data_fits, prev_cell_data_pushed, cell_state, prev_cell_state}
        casez (priority_vector)
            'b0?1??: cell_data &lt;= prev_cell_data;
            'b0101?: cell_data &lt;= new_data;
            'b0?001: cell_data &lt;= new_data;
            'b1????: cell_data &lt;= next_cell_data;
        default: cell_data &lt;= cell_data;
        endcase
    end
    else
    begin
        cell_data &lt;= cell_data;
    end

```

上面的代码块是 Verilog case 语句，其中“不要在意”使得一些信号优先于其他信号。第一种情况就是“规则 3 ”,如果那个数字被踢出，一个单元格总是取前一个单元格的内容。第二种情况是针对当前被占用但满足“严格小于”标准的单元。第三种情况是在第一个空单元格中存储最大的元素，或者“规则 1”和“规则 3”最后一种情况不是算法的一部分，但它是为了在我们想要检索排序元素的数组时将数据向上移动。

完美！既然我们的排序单元已经按照规则进行了编码，我们只需用 Verilog `generate`语句创建一个数组，我们的线性时间排序器就完成了！现在，通过[将源代码](https://github.com/Poofjunior/fpga_fast_serial_sort)上传到真正的 FPGA 硬件来尝试一下。

## 边缘案例让你变得急躁

在庆祝之前，有必要提出一些边缘案例。如果我们的未排序数组有重复会怎么样？我们可以对比硬件分类器最大容量更少的元素进行分类吗？在不把这篇文章变成小说的情况下，我可以向你保证，这个解决方案确实可以处理重复，也可以对大小从 0 到 *N* 的数组进行排序，其中 *N* 是我们在 FPGA 上合成的排序单元的总数。然而，如果不先调整源代码中的一些参数，它就不能在有符号或无符号数据类型的排序数组之间来回切换。总之，我鼓励你:*要持怀疑态度！不要相信我，除非你自己在纸上或模拟中解决了这些边缘情况。*

## 用时间换空间

我们做到了！我们已经在硬件中构建了我们自己的排序外围设备，它可以咀嚼未排序的数组，并在线性时间内对它们进行排序！但是，就像所有好得难以置信的场景一样，我们在 FPGA 资源上付出了巨大的代价。虽然我们可能有一个内置在硬件中的超快速排序器，但在耗尽 FPGA 资源之前，我只能实例化排序硬件来排序多达约 1000 个元素的 8 位数组。我们用时间换来了 FPGA 宏单元。幸运的是，当我们增加排序单元的数量来排序更大的数组时，硬件的数量呈线性增长。

## 戴上“硬件算法”的帽子

[![parameterized_length](../Images/393017f1328f6e38f5c2d3fd145204b7.png)T2】](https://hackaday.com/wp-content/uploads/2016/01/parameterized_length.png)

我在合成了一个十分排序器后，从 Atera 的 RTL 浏览器中抓取了上面的图像，有些事情很奇怪。随着我增加排序硬件的大小，或者通过调整一些顶级参数将数据类型从 8 位到 16 位再到 32 位整数，我失去了查看所有连接和信号在我脑海中来回传递的能力。只是太复杂了。电线太多了。

然而，这个设计本身是一个非常简单的单元，即*分类单元*，它重复多次，每次重复都执行完全相同的任务。因为我们知道每个分类细胞的行为，我们可以预测由这些块组成的整个系统的行为——即使我们不能在我们的大脑中可视化所有的连接！这种程序性生成的复杂性让我觉得非常美丽，就像我们在分形或递归算法中发现的那种美丽。如果你已经做到了这一步，感谢你加入我，并让我们了解你在“硬件算法”世界中的冒险经历。