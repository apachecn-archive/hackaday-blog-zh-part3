# 整理你的数据

> 原文:[https://hackaday.com/2016/11/22/squoze-your-data/](https://hackaday.com/2016/11/22/squoze-your-data/)

我要坦白一件事。我喜欢将软件压缩到一个很小的空间里，或者试图从一个循环中多削减几个周期的挑战。这就像一个错综复杂的谜题。当然，今天对这一点的需求远不如过去。今天，即使是一个“小”的微控制器也有大量的内存和资源。

即便如此，仍有一些情况需要从内存中挤出最后几个字节。也许你正试图为了某种目的最大化可用内存。也许你正在期待大规模生产，你正在使用你能找到的最小的微控制器。或者[也许你正在进行 1 kB 挑战](http://hackaday.com/2016/11/21/step-up-to-the-1-kb-challenge/)，只是想得到一些建议。

找到最大化资源的技术的一个方法是看看人们“在过去”做了什么数字设备计算机曾经有一个特殊的字符集，叫做 Squoze(有时也叫 DEC Radix-50)。当您需要将大量字符串放入内存时，这种技术会很有用。好消息是，您可以可靠地将 3 个字符转换成 2 个字节(或者像 DEC 那样，将 6 个字符转换成 4 个字节)。坏消息是，你必须选择一个有限的字符集，你可以使用。然而，这并不总是一个大问题。

## 蓝色大连接

Squoze 的关键是你必须选择 40 个你想编码的字符。这对于 26 个字母、10 个数字和 4 个标点符号(一个空格加上你想要的任何东西)来说足够了。请注意，26 个字母意味着您必须选择大写或小写，但不能两者都选。

如果只能有 40 个字符，您可能会奇怪为什么它被称为 DEC Radix-50。50 是八进制(以 8 为基数),也就是十进制的 40。Squoze 这个名字实际上被 DEC 和 IBM 都使用过。但是，在 IBM 的方案中，一个 36 位的字包含两个标志和一组 50 个字符中的 6 个字符(这次是十进制的 50)。从历史上看，对符号表使用 Squoze 就是为什么许多旧编译器只使用某些允许字符的 6 字符符号的原因(如果你对此有疑问的话)。

## 它是如何工作的

一旦你记住了 40 个字符，你就可以把它们看作一个基数为 40 的数字。保持这个想法，想想一个普通的十进制数。如果您有一串从 0 到 9 的数字，您可以像这样建立一个十进制值:

```
value=0

while not end of digits

   value=value * 10

   value = value + digit

end while
```

如果您有数字“643”，那么该值将从 0 到 6 到 64 到 643。

如果推广到以 40 为基数，“数字”是从 0 到 39 的数字(代表一个字符)，上面伪代码中的*10 就变成了*40。如果你愿意，你可以从数学上把它想成第一个数字乘以 40 的平方(1600)，第二个数字乘以 40 (40 的 1 次方)，最后一个数字乘以 1 (40 的 0 次方)。

那么，假设我们选择 0 代表一个空格，1 代表一个 A，2 代表一个 B，依此类推。字符串“A B”(中间有一个空格)将是 1，0，2。运行该算法，结果将是 1602。

[![b40enc](../Images/a5d9cdbb43c45ae4362aff5abfc3719b.png)T2】](https://hackaday.com/wp-content/uploads/2016/11/b40enc.png)

解码正好相反。例如，从 1602 开始，用 1600 做整数除法，得到 1 (A)。把那个拿走，剩下 2。除以 40 得到一个空格(0)。然后还剩 2 个——a B——所以字符串如你所愿是“A B”。

[![b40dec](../Images/34bd064862395a2878ba86e2a686d760.png)T2】](https://hackaday.com/wp-content/uploads/2016/11/b40dec.png)

## 为什么四十？

为什么要经历这么多麻烦？为什么用 40，而不用 41 或 50 呢？想想用三个基数为 40 的字符可以表示的最大数字。39*1600+39*40+39 = 63999.适合 16 位的字。如果以 41 为基数，最大可能的数字是 68920。这对 16 位数字来说太大了。

关键是，使用这种方案，您可以将 3 个字符(从您的 40 个字符集中)打包到两个字节中。与普通的 ASCII 字符相比，节省了 33%。不多，但与其他压缩方案相比，它很容易实现，并且总是节省 33%。嗯，至少，大致如此。如果你的文本长度不能被 3 整除，你可能会有一两个填充字符，这会降低效率，这取决于文本的总长度。

想象一堆存储在 EPROM 中的 LCD 菜单项。节省 33%可以为更多的字符串或更多不相关的特性留下空间。当然，你还需要考虑代码和字符表的大小。通常，您在运行时不需要编码和解码，但是仍然需要考虑一些开销。你必须评估你的需求并做出适当的决定。

## 提高

如果您对 40 个字符的限制感到恼火，您可以做一些特技来获得更多，代价是可能会损失效率。例如，对于某些应用程序，您可以假设字符串的第一个字母是大写的，其余的是小写的。或者选择 39 个最常用的字符，再使用一个作为转义字符，然后再选择 40 个，总共 79 个字符。如果对你来说效果更好的话，你也可以使用转义字符作为“移位”字符。

## 履行

你可以在 GitHub 上找到一个简单的 C 语言实现。make 文件生成两个可执行文件，一个用于编码，一个用于解码。如果您想将代码作为库进行试验，可以定义一个符号来避免构建可执行文件。

如果您愿意，编码器和解码器将使用默认字符集。你也可以自己提供一个。代码很难优化，所以如果您的应用程序共享代码和数据空间，您可能希望花一些时间来缩减代码大小。然而，对于一个演示或者如果你的代码空间是独立的和丰富的，它可能已经足够好了。

代码已设置好，因此您可以运行编码并将其输出提供给解码器:

```
$ ./encode | ./decode
Hello Hackaday. A man, a plan, a canal, Panama.
Characters in=48
(13012) HEL
(19800) LO 
(12843) HAC
(17644) KAD
(2637) AY.
(40) A 
(20854) MAN
(60801) , A
(652) PL
(2198) AN,
(40) A 
(4854) CAN
(2118) AL,
(641) PA
(22453) NAM
(3080) A. 
Bytes out=32
Full String (length=48):
HELLO HACKADAY. A MAN, A PLAN, A CANAL, PANAMA. 
$
```

请注意，编码器会将字符转换为大写字母。

## 值得吗？

这只是你工具箱里的又一个小技巧。它并不适合每个项目。你需要能够忍受这些限制。您还必须能够接受额外的代码和运行时开销。根据你掌握的数据，可能会有更好的选择。例如，数据记录器可能存储浮点数或一些其他方案。

霍夫曼编码、游程编码和其他方法可能做得更好——这取决于你的应用。然而，我确实认为挖掘一些旧技术并将它们应用到新的解决方案中是很有趣的。

如果你对此感兴趣，你应该参加我之前提到的 1 kB 挑战。Hackaday 想看看在基于微控制器的项目中，用 1 kB 的编译二进制极限可以做些什么。试一试，一路上学习旧的节省空间的技术。