# 代码工艺——嵌入 C++:多任务处理

> 原文：<https://hackaday.com/2016/07/15/code-craft-embedding-c-multitasking/>

今天，我们已经非常习惯于多任务计算机系统。我们的台式机运行电子邮件、不同工作区的几个浏览器、一个文字处理器和一些其他应用程序，显然是同时运行的。使用系统监视器或任务管理器程序来观察幕后的情况，会发现许多其他程序正在运行以支持我们的活动。当然，任何给定的 CPU 一次最多运行一个程序。多任务处理简单来说就是在活跃的进程之间快速切换，给人以同时进行的错觉。

多任务的根源可以追溯到很久以前。在早期，当计算机花费大量金钱的时候，一想到闲置的系统就让人厌恶。与处理器相比，电传 IO 速度较慢，让处理器空闲等待读卡器“嗤之以鼻”地插入下一张卡是令人无法容忍的。当时的大师们努力用富有成效的工作来填补空闲时间。这最终导致了同时运行多个程序的系统，并最终导致了一个程序中更细粒度的多任务处理。

现代的多任务处理依赖于操作系统底层 API 的支持。每个操作系统都使用自己的技术，这使得编写可移植代码变得很困难。C++ 2011 标准通过向标准模板库(STL)添加并发例程来提高语言的可移植性。这些例程使用操作系统的 API。例如，Linux 版本使用 POSIX 线程库 pthread。其结果是一个最小但有用的能力，可以在以后的标准中进行构建。C++ 2017 标准开发活动包括并行和并发方面的工作。

在本文中，我将介绍用 C++编写线程代码的一些便利和缺陷。

## 创建线程

为了在单个程序中实现多任务处理，代码被分解成多个任务，或者同时运行的[线程](https://simple.wikipedia.org/wiki/Thread_(computer_science))。声明和运行线程很简单。当管理它们和处理线程间的交互时，困难的部分就出现了。

线程是从任何为`callable`的东西创建的。这意味着一个函数或一个类，通常有一个`operator()`方法。下面是一个例子，有三个不同的可调用对象被创建为线程和一些管理技术。

```

#include &lt;thread&gt;
using namespace std;

void fa() {
}
void fb(int a) {
}
class Fc {
public:
	Fc(int a) :
			mA { a } {
	}
	void operator()() {
	}
private:
	int mA;
};

int mainx() {
	int value;

	thread t_fa { fa };
	thread t_fb { fb, value };
	thread t_fc { Fc { value } };

	t_fc.detach();

	/* ... */
	// code waits for one second
	std::this_thread::sleep_for(std::chrono::seconds(1));

// code continues in the ‘main’ thread

	t_fa.join();
	t_fb.join();

	return 0;
}

```

这些函数或类没有什么特别的。它们可以作为函数或类实例在程序中使用。当将它们与函数或`operator()`方法所需的任何参数一起传递给类`thread`的构造函数时，它们就变成了独立的线程。`thread`类是一个[可变模板类](https://en.wikipedia.org/wiki/Variadic_template)，具有可变长度的类型名。此功能允许类构造函数将参数转发给函数或类方法。

现在线程正在运行，如何停止它？不幸的是，`thread`没有提供任何方法。但是很容易创造一种方式。我使用的一种技术是作为引用传递的简单全局布尔标志:

```

#include &lt;atomic&gt;
static std::atomic_bool run { true };

void fr(int a, std::atomic_bool&amp; run) {
	while (run) {
          ...
	}
}

int value { 0 };
thread t_fr { fr, value, std::ref(run) };

```

线程检查`run`是否为假并退出。我们稍后会看到为什么使用`std::atomic_bool`。

参数可以通过值或指针传递，就像调用常规函数一样。传递引用需要使用`std::ref,`，如`run.` 所示

## 使用线程

创建线程后，执行`main()`的剩余部分。当`main()`退出时，情况变得有趣起来。正在运行的线程会发生什么？他们可能已经分配的资源(如打开的文件或串行端口)会发生什么情况？还要考虑到您可以在任何函数中启动一个线程，而不仅仅是`main()`，那么如果`fa()`创建了另一个线程然后退出了呢？新线程会发生什么情况？

该标准提供了两种处理这种情况的方式:`thread::join()`和`thread::detach()`。当函数调用`join()`时，它会一直保持到线程完成。在本例中，这是在`main()`退出之前完成的。

分离的线程独立于程序的其余部分运行。一般来说，应该在线程创建后立即调用`detach()`。当创建函数退出时，线程继续运行，甚至超过了`main()`的结尾。如果分离的线程没有使用某种技术停止，就像上面的`run`所示，就会抛出一个异常。这使得程序资源处于不确定的状态。

既没有连接也没有分离的螺纹是*可连接的*螺纹。这个可以通过`thread::joinable()`来测试。尝试加入分离的线程会引发异常。如果线程的状态不确定，应该通过调用`joinable()`来检查。

如果一个线程抛出一个未被捕获的异常会发生什么？标准规定`std::terminate()`被调用，调用`std::abort`结束程序。您可以通过捕捉异常或指定一个`std::terminate_handler`来避免这种情况。这方面的详细信息可以在 C++参考网站或书籍中找到。

如果合适的话，加入线程的需要需要类似于管理资源(例如文件或内存)的努力。它是通过同样的方法解决的，这也是类存在的一个原因:资源分配是初始化(RAII)。类构造函数执行初始化，包括资源获取，而析构函数释放资源。一个简单的处理线程的类(见最后的注释)是:

```

struct thread_guard: thread {
	using thread::thread;
	~thread_guard() {
		if (joinable()) {
			join();
		}
	}
};

```

类`thread_guard`是`thread`的派生类。`using thread::thread`告诉编译器使用所有线程的方法，消除了为`thread_guard`创建构造函数的需要，因为我们只想提供一个析构函数。析构函数测试线程是否是可连接的，也就是说，它没有被分离，如果允许，就进行连接。这提供了两种能力。创建线程的函数不再需要显式地加入线程，尽管在函数退出之前可以安全地加入。如果有什么东西中断了创建函数，比如异常，析构函数将执行连接。

在示例代码中，命名空间`this_thread`通过调用`this_thread::sleep_for()`来演示。这个命名空间提供了三个例程来控制线程的计时。如图所示，你可以睡一段时间，一直睡到指定的时间，或者干脆放弃。名称空间中的第四个例程获取线程的标识号。它在`main()`中的出现指出它也是一个线程。`chrono`头非常值得研究，因为它提供了方便的工具来处理时钟、特定时间点和持续时间形式的时间值。

## 赛车螺纹

让我们回到在`atomic`头中定义的`atomic_bool`，以及许多标准类型的原子版本。原子变量是防止变量竞争的必要条件。读取或写入一个变量有时需要数百个处理器周期，即使是像布尔值或字符这样小的东西。在此期间，可能会发生中断，或者用新任务替换当前任务。如果这个新执行的代码读取或写入同一个变量，该变量的状态就会被破坏。例如，一个 32 位整数包含四个字节。第一个任务读取两个字节，被中断，新例程写入所有四个字节，当第一个任务重新启动时，它读取最后两个字节。它读取的最初两个字节现在无效。原子操作可以防止这种情况发生。

当试图访问资源时，会发生其他争用情况。如果示例中的任务向`cerr`发送输出，就会发生这样的竞争。一个任务可能开始输出文本，被任务交换中断，新任务也开始向`cerr`写入，导致它们的输出混杂。

处理这一问题的成熟技术是互斥，简称为*互斥。*

```

#include &lt;mutex&gt;
   std::mutex cerr_mutex;
   . . .
   cerr_mutex.lock();
   cerr &lt;&lt; &quot;Hello Hackday! &quot;  &lt;&lt; '\n';
   cerr_mutex.unlock();

```

当一个任务想要访问一个资源时，互斥锁被锁定，当任务完成时，互斥锁被解锁。这是一个快速和廉价的操作。如果另一个任务请求互斥体，该任务将被挂起，直到互斥体被释放。

使用多个互斥体会导致死锁情况。任务 A 依次请求互斥体 X 和 Y。任务 B 请求 Y，然后请求 x。每个任务都可以获得第一个互斥体，但是都不能获得第二个。该标准提供了函数`lock(X, Y, …)`，它会一直等到参数列表中的所有锁都可用。

`mutex`头文件提供了更多处理竞争条件的类和函数，因此在使用线程时值得仔细研究。

## 在窗帘后面偷看

在进行多任务处理时，了解一点幕后发生的事情会有所帮助。在 Windows 或 Linux 上，我们使用的是*抢占式*多任务处理，而不是*协作式*多任务处理。

在前者中，系统由定时器中断驱动，使用调度算法在系统上运行的任务之间切换。一个合作的多任务系统依赖于任务自愿放弃控制，以便其他任务可以被调度

最简单的抢先调度程序是时间分片，允许每个任务运行一段特定的时间。如果一个任务屈服于 IO，等待一个互斥体，或者主动地，下一个任务被允许继续。更复杂的算法，即使是协同多任务处理，也能在高优先级任务获得更多时间的情况下执行优先级调度。在实时系统中，标记为实时的任务可以得到他们需要的时间。优先多任务开发人员必须确保所有任务都有足够的时间。他们可能不会这样做的一个原因是，当高优先级任务消耗了所有的处理时间，使低优先级任务挨饿。当低优先级任务抢占互斥体，阻止高优先级任务运行时，会出现被称为*优先级反转的问题*。

### 多任务成本

多任务处理消耗时间和内存资源。当任务交换发生时，任务使用的处理器寄存器被压入其堆栈。从下一个任务的堆栈中弹出该任务的寄存器，使其开始运行。这显然需要时间和内存，因为每个任务必须分配一个堆栈。设置堆栈大小几乎是一门艺术。必须为任务可能需要的函数调用和基于堆栈的局部变量分配足够的空间。此外，当发生处理外部事件的中断时，比方说一个串行端口接收一个字符，该中断需要堆栈空间。

Arduino 生态系统通常不支持这些形式的多任务，因为处理器没有多任务所需的堆栈内存。Arduinos 上有一些可用的调度技术，它们是协作性的，但不保存任务的状态，而是将负担推给任务本身。C++并发库是不可用的，因为没有底层系统来提供多任务 API。Arduino 社区已经开发了大量的 [调度程序库](http://playground.arduino.cc/Main/LibraryList#Sched)用于这些系统。

## 包裹

多任务是保持处理器忙碌的一种有用的技术。必须记住，它不是万灵药，应该一如既往地进行测试，以确保多任务处理的开销不会超过它所能提供的。

另一个考虑是对代码组织的影响。将程序划分为逻辑部分作为独立的任务可以使代码的创建、测试和调试更加容易。单个开发人员可以更容易和独立地处理代码的不同部分。即使是像我这样的个人，也会发现更容易专注于特定任务的代码，而忽略其他过程。

我只谈到了创建多任务系统的复杂需求。还有许多其他 C++功能可用于处理任务，包括安全地协调它们的活动和在它们之间传输数据。一旦你开始使用更大的代码库，将代码分解成多个任务可能对你的系统和理智有益。

### 注意事项:

这个`thread_guard`类是来自比雅尼·斯特劳斯特鲁普的《C++编程语言》，第 4 ^期版。如果你想了解 C++，请阅读这本书。