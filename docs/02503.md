# Linux:需要程序集

> 原文:[https://hackaday.com/2016/06/14/linux-assembly-required/](https://hackaday.com/2016/06/14/linux-assembly-required/)

有时你可能需要使用汇编来达到你的项目目标。以前我更关注在 gcc 或另一个编译器中嵌入汇编。但是就像有些人想用弓打猎，或者手工做面包，或者做很多其他不再绝对必要的事情一样，有些人喜欢用汇编语言编写。

在 DOS 的旧时代，用汇编语言编写相当容易。这是件好事，因为在那些机器上有限的可用资源上，这可能是让事情变得合适的唯一方法。如今，在 Windows 或 Linux 下，甚至在 Raspberry Pi 上，很难找到如何让汇编语言起步的方向。

## 你需要什么？

显然，你需要一个汇编器。当然，如果你是一个真正的大男子主义黑客，你可以使用十六进制编辑器从你的二进制符号手动构建可执行文件，但在现实中，这可能对每个人来说都太多了。你还需要了解你的 CPU 结构，指令集，汇编程序使用的助记符，以及操作系统的接口。

在这个例子中，我们将看看在 PC 上为 Linux 编写代码。同样的想法也适用于其他 Linux 平台，比如 Raspberry Pi。其他系统(如 Arduino 中的 AVR)的细节会有所不同，但步骤的基本轮廓是相同的。当然，有些系统根本没有操作系统，这使得它既容易又难。更容易，因为你不必遵从。更难，因为您必须找到资源(如串口或显示器)并自己处理它们。

## Linux Asm

一般来说，如果你有一个 C 编译器，你可能有一个汇编器。对于 gcc，这个汇编器被命名为 gas 或 as。这是有用的，但是他们并不总是像你希望的那样友好。在基于 PC 的 Linux 上，您可以考虑使用[全网汇编器](http://www.nasm.us/) (nasm ),它可以和您的软件包管理器一起安装。

即使是 Linux，也要考虑平台。就我而言，我使用的是 64 位英特尔/AMD 电脑。但是您可能使用 32 位版本或者运行在 ARM(或者 Linux 支持的任何其他 CPU)上。如果您对此感兴趣，甚至还有一个用于 64 位 Linux (x32)的 32 位接口。那么，第二项任务就是弄清楚 CPU 的体系结构是什么样子。

首先，您需要理解寄存器(如下图所示)。当然，该图假设您对这些寄存器的用途有所了解，因此您需要在针对您的特定处理器的参考手册、数据手册或教程中做更多的研究。

[![x86](../Images/cacd6d62e40b1e4adc44b24d6f8d93b5.png)](https://hackaday.com/wp-content/uploads/2016/05/x86.png)

Register image [by Liam McSherry](https://commons.wikimedia.org/wiki/File:Table_of_x86_Registers.png) CC BY-SA 3.0

这对任何现代 CPU 来说都是令人畏惧的。您可以随时找到数据手册，但解析其中一份可能需要很长时间。如你所料，网上还有大量的资源。如果您正在使用 AVR 之类的产品，数据表非常简单。更复杂的处理器通常有很多你不需要知道的细节，所以这是数据手册的部分问题。例如，英特尔处理器有许多针对编写操作系统的人的特性。除非你在写操作系统或者裸机编程，否则你不会关心这些。

此外，除非您关心裸机编程，否则您需要了解应用程序二进制接口或 ABI，它定义了程序如何启动以及如何调用库和服务。比如 64 位 Linux，可以[读这个文档](http://www.x86-64.org/documentation/abi.pdf)。

## 在实践中

如果你开始阅读数据表和 ABI 文件，你可能会很快就想放弃。然而，它真的没有那么糟糕。您可以找到许多网站([就像这个](https://filippo.io/linux-syscall-table/))来找出调用系统调用的细节。

例如，代码为 1 的系统调用写入文件。如果你在上面的网站上查找，你可以双击相应的行，看看你需要如何打电话。此图像是如何使用该表的示例。

在这种情况下，您将看到%rdi 获得文件描述符，%rsi 获得指向要写入的数据的指针，%rdx 是要写入的字节数。调用 60 是出口函数(可以在同一个表上查)。您可能知道文件描述符 1 是 Linux 程序的标准输出设备。所以使用 nasm，一个非常简单的程序可以是这样的:

```
section .data
    msg db "Hello Hackaday!",10
    msgend equ $

section .text
    global _start
_start:
    mov rax,1 ; print msg using syswrite (1)
    mov rdi,1 ; fd 1
    mov rsi,msg ; buffer
    mov rdx,msgend-msg ; count
    syscall
    mov rax,60 ; exit
    mov rdi,0  ; return code
    syscall
```

当然，这是你能写的最简单的程序，但是它是有效的。一个简单的 nasm 命令完成装配:

```
nasm -f elf64 -o hello.o hello.asm
```

然后，您需要像链接 C 编译器的目标文件一样链接它(如果您愿意，您甚至可以链接 C 编译器生成的一些目标文件):

```
ld -o hello hello.o
```

## 去集合吧

很明显，你有很多细节要填写，但关键是，这并不一定很难。如果您使用 32 位 Linux 或 ARM，细节会有所不同(首先，会有不同的系统调用号和寄存器)。

提醒一下，我并不是说用汇编语言编写整个程序是个好主意。但这是一个挑战，也可能带来意想不到的好处。如果你想做的只是优化几个热点，你最好坚持内联汇编(上次讨论的)。但是如果你想灵活运用你的逻辑和编程能力，试着用汇编语言写一些完整的程序。你可能会让它工作，也可能不会，但我打赌你会学到一些东西。