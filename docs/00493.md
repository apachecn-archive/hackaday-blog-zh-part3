# GNU Radio 入门

> 原文:[https://hack aday . com/2015/11/11/getting-started-with-GNU-radio/](https://hackaday.com/2015/11/11/getting-started-with-gnu-radio/)

软件定义无线电(SDR)——使用软件而不是电子设备处理无线电信号的能力——不可否认是迷人的。但是，离能够使用现成的 SDR 软件和自己编写软件有很大差距。毕竟，SDR 需要大量高速数字信号处理(DSP)。

没有多少人能从零开始建造一台现代 PC，但几乎任何人都可以得到一块主板、一些 I/O 卡、一个电源和一个机箱，然后组装成一个定制系统。这就是 GNU Radio 和 SDR 背后的理念。GNU Radio 提供了丰富的 Python 函数，可以用来创建复杂的 SDR 应用程序(或者任何 DSP 应用程序)。

如果 Python 仍然不适合你(或者即使适合)，有一种更简单的方法来使用 GNU Radio:GNU Radio Companion(GRC)。这主要是一种图形化的方法，允许你图形化地将模块连接在一起，构建简单的图形用户界面来控制你的新收音机。

尽管您通常认为 GRC 与无线电有关，但它实际上是构建任何 DSP 应用的良好框架，这就是我将在下面的视频中向您展示的内容。GRC 有一个信号发生器模块和你的声卡接口。它甚至能够读取和写入文件系统的数据，因此您可以使用它来进行许多 DSP 应用或仿真，而无需额外的硬件。

**更新:**不要错过后续的帖子[使用 SDRPlay 构建基于 GNU Radio 的接收器](https://hackaday.com/2015/11/12/your-first-gnu-radio-receiver-with-sdrplay/)。

 [https://www.youtube.com/embed/ufxBX_uNCa0?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent](https://www.youtube.com/embed/ufxBX_uNCa0?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent)

T2】

## 积木

有几个关键的构件组合在一起使特别提款权成为可能。第一个是以某个采样率采样的某个输入设备(源)。对于音频设备，样本将是实数。然而，无线电设备更可能提供具有 I 和 Q 分量的复数。

如果您不熟悉将信号表示为 I 和 Q 分量(有时称为正交数据)，这是一个大话题(有一个[精彩的 3D 解释](http://whiteboard.ping.se/SDR/IQ)，一个来自泰克的[，还有一个来自美国国家仪器](http://www.tek.com/blog/what%E2%80%99s-your-iq-%E2%80%93-about-quadrature-signals%E2%80%A6))。然而，要开始使用 GRC，您不需要直接理解正交信号背后的理论。只需知道 I 和 Q 信号可以组合起来表示任何波形，反之，任何波形都可以分解成一系列 I 和 Q 值。但是，对于 GRC，理解这一点并不重要(在大多数情况下),就像您可以在不知道 PCI express 总线上有什么信号的情况下使用显卡一样。

## GRC 项目的起步

[![](../Images/c3a466632e5f387542e38925f9d90638.png)](https://hackaday.com/wp-content/uploads/2015/10/grc0-cropped.png) 你可以在下面的视频中找到一个简单的入门项目。GRC 使用框图(流程图)来表示您的项目。当您创建一个新的流图时，您会看到已经存在两个块:一个用于选项，一个名为 samp_rate 的变量。选项块最重要的部分是设置您想要使用的图形工具包(WX 图形小部件或 QT 小部件)。就我们的目的而言，这并不重要，但在视频中，我将选择 Qt。采样速率对您的设计至关重要，因此有一个特殊的变量。大多数其它模块将获取该变量的值，并将其用于采样速率。然而，这并不总是你想要的，但它是一个很好的起点。对于这个例子，我最终将从声卡获得输入，所以我想要一个大多数声卡都支持的采样率(48 kHz)。首先，我让这个例子非常简单，就像你在上图中看到的那样。

![fft1](../Images/72e3527d47b3c66021f0d48a350ee73a.png)首先，你将在流程图上放置一个产生 IQ 数据(复数形式)的信号源。信号发生器模块实际上会产生过多的数据，降低 CPU 的速度。由于采样速率为 48 kHz，每秒产生超过 48，000 个样本是没有意义的。为了确保这一点，您将添加一个节流块，并将其连接到发电机。

连接颜色相同(因此数据类型相同)的端口很简单。只需点击一个端口，然后点击另一个。顺序无关紧要，您可以将多个输入连接到一个输出。如果端口数据类型不匹配，您将需要使用类型转换器(示例视频将在后面展示)。

我的简单示例的最后一部分只是一个使用 QT 的 FFT 显示块(与您在 options 块中设置的图形库相同)。一旦所有连接在一起，你可以按下播放按钮，你应该看到信号的 FFT。

## 添加更多

诚然，这并不十分令人兴奋，但你必须在奔跑之前先走一步。在视频中，您将看到您可以添加其他图形元素，如滑块来改变频率，选择器来选择信号类型。最后，您将添加一个声卡输入(它不需要节流；事实上，在这种情况下，两者都有是无害的，但通常在使用真正的硬件块时，您会移除节流块。然而，它需要的是一种类型转换，将真实数据转换为复杂数据。最终项目出现在左侧。

我鼓励你打开 GRC 观看视频。你可以通过没有任何特殊硬件和声卡源应该与你的声卡工作(当然你有一个声卡在你的电脑，我猜)。

一旦你对这个例子感到满意，试着扩展它。添加声卡接收器以输出音频。尝试过滤来自测试源的音频。例如，低通滤波方波在不同频率下听起来像什么？如果你喜欢冒险，可以尝试过滤声卡音频，并将其写入 wave 文件进行播放。您需要的所有工具都在 GRC 工具面板上。

## 如果你使用 PulseAudio

顺便说一句，如果你使用 Linux(像我一样)并使用 PulseAudio 作为你的声音系统，你可能会得到断断续续的音频播放。解决这个问题很简单。只需在您的主目录中创建一个文件:~/。gnuradio/config.conf(如果已经存在，则进行编辑)。您需要以下内容:

```
[audio_alsa]
nperiods = 16
period_time = 0.100

```

如果这样做没有效果，您可以进一步增加 nperiods。

## 下次

**更新:**继续到[通过示例制作无线电接收器](https://hackaday.com/2015/11/12/your-first-gnu-radio-receiver-with-sdrplay/)。

下一次，我将拿出 SDRPlay 设备，做一个真正的收音机。如果你想要很多详细的理论，请查看[【迈克尔·奥斯曼】教程系列](http://hackaday.com/2015/10/10/sdr-tutorials-from-michael-ossmann/)。它是针对 HackRF 的，但理论仍然适用。当然，GNU Radio(和 GRC)并不是做 DSP 软件的唯一途径，[正如我们在](http://hackaday.com/2015/08/22/spectrum-painting-on-2-4-ghz/)之前提到的。