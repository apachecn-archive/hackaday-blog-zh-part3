# 嵌入埃利奥特:中断，坏

> 原文:[https://hack aday . com/2015/09/25/embed-with-Elliot-interrupts-the-bad/](https://hackaday.com/2015/09/25/embed-with-elliot-interrupts-the-bad/)

我们喜欢微控制器项目中的中断。如果你还没有被说服，去阅读本系列的第一部分,在那里我们讨论了中断的最好的方面。

但并非一切都是阳光和水仙花。中断发生在正常程序流之外，实际上抢占了它。每当触发事件发生时，微控制器就会放下它正在运行的任何代码，开始运行你的 ISR。当你需要的时候，这种力量是巨大的，但是回想一下蜘蛛侠的咒语:*强大的力量带来巨大的责任*。您有责任为 ISR 的隐式高优先级进行设计，并确保您的主代码在中断调用之间仍能完成其工作。

换句话说，在微控制器代码中添加中断会引入调度和优先级问题，这是您以前不必处理的。现在让我们来看看这个方面，我们将把使用中断的真正可怕的副作用推迟到下一次。

## 饥饿:长时间中断

让我们回到一个具体的例子。假设您从加速度计获得一些输入，您想对其进行一系列运算，以确定您的电路板指向哪个方向，然后您可能想将该倾斜信息发送到串行终端进行调试。

天真的方法是在中断中处理所有的数学和串行数据。毕竟，您只需要处理新输入的加速度计数据，对于每个新值，中断触发一次。这似乎是一个完美的匹配，不是吗？

```

ISR(INT1_vector){
	read_accelerometer();
	complicated_math();
	wait_for_serial_line_to_clear();
	send_results();
}

int main(void){
	while(1){
		do_stuff();
		if (emergency_shutdown_pressed()){
			turn_off_killer_laser();
		}
	}
}	

```

为了让这个例子更加生动，我们还通过在`main()`循环中进行轮询，实现了一个杀手激光器的紧急关闭。只看主循环，如果`do_stuff()`跑得很快，我们应该状态不错吧？紧急关闭将被频繁轮询，对吗？

没有。我们在 ISR 中隐藏了很多工作，因为它在 ISR 中，它抢占了在主体中运行的代码。因此，当 ISR 正在进行繁重的数学计算并对输出数据进行排队时，杀手激光正在你的实验室里燃烧。显然，我们至少在这里有一个优先级不匹配；向屏幕发送数字不可能比用户安全更重要，对吗？但是，即使没有优先级问题，我们的 ISR 也做得太多了。

当您有许多由中断处理的输入时，重量级中断的问题就变得更加复杂了。你的代码可能会把所有的时间都花在 ISR 上，只剩下很少的时间用于主例程，这让它很饥饿。例如，如果您有两个长时间运行的 ISR，并且第二个 ISR 在第一个 ISR 仍在运行时被触发，然后第一个 ISR 在第二个 ISR 运行时重新触发，依此类推，您的主循环可能永远不会看到任何 CPU 时间。

ISR 写作的黄金法则是:保持简短和甜蜜。ISR 是代码中优先级最高的部分，所以要尊重他们。在中断中只做绝对最小值，让你的代码尽快恢复正常。

将 ISR 削减到最低限度并不困难，但是需要声明一些可以在 ISR 和主流之间传递的额外变量。这样，不用在 ISR 内部处理每次更新一次的串行传输，您可以简单地标记它需要处理，让主例程来处理它。例如:

```

ISR(INT0_vector){  /* now handles killer laser shutdown */
	turn_off_killer_laser();
}

/* Some volatile variables to pass to/from the ISR */
volatile uint8_t raw_accelerometer_data;
volatile enum {NO, YES} has_accelerometer_data = NO;

ISR(INT1_vector){
	raw_accelerometer_data = read_accelerometer();
	has_accelerometer_data = YES;
}

int main(void){
	while(1){
		do_stuff();

		if (has_accelerometer_data == YES){
			complicated_math();
			wait_for_serial_line_to_clear();
			send_results();
			has_accelerometer_data = NO;
		}
	}
}

```

我们已经把激光切断开关移到了最高优先级中断。法律可能还要求您在现实生活中使用物理断路开关，但在对人类存在危险的情况下，通常会使用基于不合格数据的自动断路开关。

现在，加速度计 ISR 只做了它需要做的事情——记录新数据并设置一个标志，让代码主体知道它有新的东西要处理。我们还通过将`complicated_math()`放入`main()`而不是中断，使其可抢占。

那些关注过上一期中中断与轮询之争的人会认为这是一种混合:中断获取数据，而主例程轮询新数据(以`has_accelerometer_data`标志的形式)并进行较慢和较低优先级的串行处理。这将加速度计处理任务分为低优先级和高优先级操作，并在适当的位置处理它们。一切都好。

最后，本例的另一个可行模式是使用一个文本缓冲区来处理通过串行接口发送的数据，并在每次主循环中轮询该缓冲区。这样，多个子程序可以很容易地共享串行服务。对于简单的情况，ISR 甚至可以直接写入文本缓冲区，而不涉及标志等等。例如，这是 Arduino 库提供的更好的服务之一。我们将很快就这个非常常见的应用程序发表一篇文章。

## 饥饿:频繁的中断

中断有助于快速处理事件，轻量级 ISR 有助于防止主循环饥饿。但是“轻量级”首先是相对于中断被调用的频率而言的。无论 ISR 内部发生的事情有多少，总会有一些有限的调用和返回开销。(尽管有一些巧妙的、特定于机器的方法可以最小化这种情况，但这超出了本文的范围，我们很乐意在后面讨论。)ISR 最终还是要做*一些事情*。

如果您的 ISR 将被非常、非常频繁地调用，那么即使是一个轻量级的中断也会阻塞主循环。想象一下，进入和退出一个中断总共需要 40 个周期，而中断触发事件最终每 50 个周期发生一次。如果您的 ISR 运行时间超过 10 个周期，那么您就完全被阻塞了，无论如何，您的主循环代码都会慢如蜗牛。即使是最短的中断也需要一些时间来调用和返回。

按钮可能会引起过于频繁的中断。一方面，通过中断处理按钮输入很有吸引力，对不经常出现的输入做出快速响应。但是现实世界中的按钮经常“弹跳”——当里面的金属板相互接触时，在几毫秒内多次接通和断开电路。这些小故障会频繁地触发中断，以至于 ISR 跟不上，因此主循环会被阻塞一段时间。

使用按钮，您可以非常确定它只会反弹几毫秒，限制了主循环饥饿的程度，因此我们认为这种情况在技术上有缺陷，但实际上是良性的。但同样的原理也适用于任何噪声信号，如果噪声输入会导致中断过载，您就需要考虑如何处理这种噪声。想象一下，模型火箭制导系统上的一根电线松了，导致主回路无法正常工作。对于关键系统，对输入进行一些过滤以防止其来回波动可能是个好主意。

## 哟老兄，我听说你喜欢打断…

AVR-GCC 等编译器在进入 ISR 时会关闭全局中断屏蔽位。为什么？因为您可能不希望中断被其他中断打断。如果它们本来就是短小的代码，那么更合理的做法是完成这个 ISR，然后处理下一个。但是还有另一个原因，你应该警惕你的中断中的中断。

每次调用 ISR 或任何其他函数时，编译器都会将变量和程序计数器的当前位置(跟踪 CPU 当前正在执行的指令)存储在名为[的内存位置(堆栈](https://en.wikipedia.org/wiki/Call_stack))中。在函数内部嵌套函数会将越来越多的变量推到堆栈上，当堆栈填满到溢出时，就会发生不好的事情。因为微控制器通常具有相对有限的 RAM，这可能是一个真正的问题。

如果你是那种坚持写递归函数的程序员，你至少可以估计一下你的函数会调用自己多少次，并且弄清楚你是否有可能撞毁堆栈。但是由于中断是由外部事件触发的，它们不在你的控制之内，允许中断互相中断会让你希望它们不会嵌套太深。这就是处理 ISR 时默认关闭全局中断使能位的基本原理。

当然，您可能正在运行一些较低优先级的中断，您绝对希望被进一步的中断所中断。即使在 AVR-GCC 上，也有这样做的规定，所以不是说不能。在最小的微处理器上，当你让中断中断其他中断时，要保持明智。

例如，在我们上面的加速度计与杀手激光的例子中，因为我们只有两个 ISR，而且它们有非常明确的优先级关系，我们可以从`read_accelerometer()`函数中重新启用全局中断位，或者定义整个 ISR 为可中断的。在 AVR 平台上,“avr/interrupt.h”允许用户定义可中断的中断，如下所示:

```

ISR(INT0_vect, ISR_NOBLOCK) {
...
}

```

现在你知道了。负责任的使用就好。

## 下一篇专栏:丑陋的人。

在接下来的 Elliot 嵌入中，我们将处理丑陋的:竞争条件和原子性的失败。这个故事的简短版本是，中断将在最糟糕的时候发生，你必须相应地调整你的思维，否则混乱就会随之而来:`if()`块可以“不正确地”运行，变量可以呈现完全“错误”的值。

但是现在，为了避免使用中断的“坏处”，只要记住保持你的 ISR 简短，不要害怕细分需要不同优先级的任务。听起来很简单，不是吗？