# 需要拆卸

> 原文:[https://hackaday.com/2016/12/23/disassembly-required/](https://hackaday.com/2016/12/23/disassembly-required/)

如果你真的想黑软件，你将面临一个不得不拆开别人的机器代码的时刻。如果你不是很有条理，它甚至可能是你自己的——源代码确实会丢失。如果你想给所有人留下深刻印象，你只需通读十六进制代码(嗯，真正强悍的老鸟会用二进制来读)。即使 CPU 只有少量指令，这也很难做到。

更实际的方法是使用一种叫做反汇编器的工具。这只不过是一个将数字机器代码转换成符号指令的程序。魔鬼当然在细节中。真正的程序是混乱的。例如，反汇编程序并不总是能搞清楚代码和数据之间的区别。数据和代码之间的转换点也很棘手。

## 何时不使用

如果你用汇编语言编写你自己的程序，反汇编程序通常是不必要的。反汇编不能恢复变量名、一些函数名，当然还有注释。如果您使用高级语言，并且想要检查您的编译器输出，您可以很容易地让编译器提供汇编语言输出(见下文)。

反汇编程序的真正价值是当你没有源代码的时候。但这并不容易，尤其是对于任何不平凡的事情。在大多数情况下，做好做大量侦查工作的准备。

## 在线工具

具体使用什么工具将取决于您想要使用什么样的 CPU 架构。然而，有一个非常有趣的在线工具[可以处理许多不同的架构。在过去，反汇编程序只是在文件或打印输出中生成大量输出。但这个在线版本做了很多智能分析，并提供超链接交叉引用。更好的是，你可以交互式地给它一些关于主题代码的提示，它会改善结果。您甚至可以与其他人合作，这在处理大型项目时非常方便。](http://disassembler.io)

## 它是如何工作的？

为了体验一下该工具的工作原理，请看一下这个简单的程序:

```
#include <stdio.h>
#include <stdlib.h>

void do_it(void)
{
 printf("Howdy Hackaday!\n");
}

int main(int argc, char *argv[])
{
 char *p=malloc(100);
 do_it();
 free(p);
 return 0;
}
```

我在 Cygwin 下用 GCC 把这个编译成可执行文件。当然，这是作弊，因为我们已经知道了太多的代码，这是一个公平的测试。此外，反汇编程序可以从可执行文件中提取信息，这有助于它做诸如分离代码和数据之类的事情。别忘了，如果我们真的想看看编译器生成了什么，我们可以[直接问它](https://hackaday.com/2016/06/08/gcc-some-assembly-required/)。如果你想要一个更真实的例子，网站上有一个菜单，你可以从中选择几个例子，但是它们要复杂得多。

## 在网络上

一旦有了可执行文件，就可以使用 File 菜单将它上传到反汇编器中(当然是使用 upload 项)。因为 Windows 使用的 PE 文件格式包含一些信息，所以反汇编程序知道一些符号和段。左侧显示了一种按钮栏，允许您在左侧导航窗格中选择不同的项目。顶部的按钮显示符号，如果你点击 main 并确保右边顶部的选择器设置为反汇编，你将看到你的主功能(见下文)。

[![screen1](../Images/67797c0061f9eff45bc9c6c0e37334e9.png)T2】](https://hackaday.com/wp-content/uploads/2016/12/screen1.png)

其他左侧窗格允许您选择字符串、进行搜索或识别数据项。沿着右上方，您可以选择查看调用图、十六进制转储、文件部分(因为这是一个结构化文件而被填充)以及关于文件本身的信息。

一切有意义的东西都是有联系的。例如，如果你点击对`do_it`的调用，视图将跳转到那部分代码。不过，这似乎并不总是适用于数据。下面是`do_it`功能: [![screen2](../Images/35d84dffe86ed73b9752f9ee4934c220.png)](https://hackaday.com/wp-content/uploads/2016/12/screen2.png)

如果你点击`puts`，你将跳转到代码，但是看看它前面的`lea`指令，它加载要打印的字符串。没有联系。

你可以浏览字符串或进行搜索。但是，您也可以注意地址和部分(。rdata)。点击部分显示，您可以跳转到。rdata 直接。从那里您可以快速找到地址，并看到您期望的字符串。

通过右击屏幕(或使用键盘命令)，你可以添加注释，定义变量和函数，或者告诉工具什么区域是代码，什么区域是数据。在这种情况下，我们已经完成了一些工作，但是如果您花时间，您可以很好地记录反汇编。例如，下面是提供的一个示例:

[![screen3](../Images/1604885ced3bfc1c77aa39a06969c5b9.png)T2】](https://hackaday.com/wp-content/uploads/2016/12/screen3.png)

显示跳跃的箭头是一个很好的接触。

## 前进

你可以做得更糟，而不是采取帮助菜单上的教程。该工具声称支持 60 个 CPU，但要找到列表，你需要打开“实时视图”的配置菜单，在那里你可以输入十六进制代码或加载二进制文件。他们确实有相当多的产品，包括 x86、ARM、AVR、VAX、System 390、MIPS、PPC，甚至 Z80。很遗憾没有看到 1802，但我仍然可以自己反汇编它的代码。

下一次你想看一些二进制代码时，这个网站是一个有用的工具。仅仅是它有这么多 CPU 这个事实就有价值了。我手边不太可能有 VAX 反汇编器，更不用说有这么多分析和协作工具的反汇编器了。