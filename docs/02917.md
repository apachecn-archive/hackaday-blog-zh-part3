# 什么会出错？I2C 版

> 原文:[https://hack aday . com/2016/07/19/what-could-go-error-I2C-edition/](https://hackaday.com/2016/07/19/what-could-go-wrong-i2c-edition/)

我应该比现在更喜欢 I2C。原则上，这是一个出色的协议，与异步串行和 SPI 相比，它定义明确，标准化程度很高。理论上，仅用两根电线(和地)就可以将多达 127 个设备连接在一起。在同一条总线上允许有多个时钟主控器，并且有一种方式让从设备发信号通知主控器需要等待。听起来很完美。

实际上，仅使用两条线的代价是一个非常复杂的信号和寻址系统，这既带来了缺陷，也带来了调试的机会。虽然 I2C *确实减少了你需要的信号线数量，但是当你在同一对线上有很多设备时，这就变得很危险，当它们都符合同一标准时，你就很幸运了。我从没见过一辆公交车上有 20 个设备，更别说 127 个了。*

但是，I2C 仍然有它的位置。与最接近的竞争协议 SPI 相比，I2C 旨在连接一批速度较慢、价格较低的设备，而不需要使用大量的铜资源。如果你需要将一些便宜的温度传感器连接到一个微控制器上(并且它们的总线地址不会冲突)，I2C 是一个很好的选择。所以这里有一个当它不起作用时让它起作用的指南。

## 物理层

[![Image from Sparkfun's I2C Tutorial: https://learn.sparkfun.com/tutorials/i2c](../Images/c06f3414d5ba7e1aef1e8f5d710e3805.png)](https://hackaday.com/wp-content/uploads/2016/07/51adff65ce395ff71a000000.png)

Image from [Sparkfun’s I2C Tutorial](https://learn.sparkfun.com/tutorials/i2c)

让我们从电线开始吧，因为在那里会出现数量惊人的小故障和复杂情况。尽管 SPI 以最少的协议开销勉强度日，但却付出了大量电线的代价，而 I2C 只要求你铺设两条线路:一条用于时钟(SCK)，一条用于数据(SDA)。当以不同电压运行的系统接口时，这种简单性是有代价的。

I2C 器件也可以每行一个晶体管，因为这两条线是由一个(或多个)外部电阻上拉的。这听起来不错，但会给高速信号和高电容线路带来问题。

所以让我们进入细节。

### 上拉电阻与寄生电容的关系

依赖上拉电阻的问题是“寄生电容”。虽然我们通常认为电容器是由两个大的导电板组成，中间有电介质(或空气),但两条平行线之间也存在相同的电荷存储容量。这意味着 I2C 信号线和 PCB 的接地层或任何其它相邻信号之间存在一些小电容。

[![i2c.sch](../Images/d3709722265a62d71c2e70532a88b93d.png)](https://hackaday.com/wp-content/uploads/2016/07/i2c-sch.png) 这种寄生电容是指信号线(数据或时钟)上的电压电平不能瞬间变化，而是需要向导线中泵入一些有限的电流来给这个偶然的电容充电。对于 SPI 和异步串行，这不是一个很大的问题，因为高低电压电平都是由相关芯片上的晶体管驱动的*。寄生电容在 I2C 非常重要，因为器件会拉低信号线，但它们会被电阻(或高性能设计中的恒流源)拉高。*

 *这意味着，虽然从高到低的转换几乎可以瞬间完成，但随着线路充电恢复，从低到高的转换总是需要一些时间。这意味着信号线不能太长，以防止寄生电容。根据标准，400 皮法是最大值。上拉电阻的最佳选择因线路电容、所需速度和各种器件中晶体管的强度而异，但 4.7 千欧是正常的。

[![scope_15](../Images/9ec9742ffadaa8cb5cefd4326077bd68.png)](https://hackaday.com/wp-content/uploads/2016/07/scope_15.png) 这里有一些 I2C 对话的特写镜头。(我们将在下面讨论协议。)请注意，向下的转变几乎是瞬间的，但回升到 VCC 需要一些时间。如果这些转换需要更快，可以使用更小的电阻来上拉，这样会增加总线的功耗。

看到数据线上那些与时钟同步的微小上下尖峰信号了吗(反之亦然)？这是将时钟和数据线耦合在一起的另一个寄生电容的影响。这不足以改变任何数字值，它会很快衰减，但在更极端的情况下，这也会导致问题。

保持线路短并且彼此之间以及与周围环境的耦合最小是解决办法。如果你在 I2C 线的上面/下面走其他的数据线，安排它们很少交叉，并且成 90 度角。具有弱电阻上拉的长线几乎与天线一样好。

### 双向—电压电平转换

数据线(`SDA`)必须是双向的:主 IC 和从 IC 都必须读取其电压。但是，当芯片在不同电压下工作时，线路一端必须被拉高电压，另一端必须被拉低电压。

幸运的是，有一个[应用笔记(PDF)](https://cdn-shop.adafruit.com/datasheets/AN10441.pdf) 。标准解决方案是每条线路使用一个 MOSFET，滥用本征体二极管将信号从高端传递到低端。这是一个很好的黑客，你会喜欢读它。你可以从大多数爱好者友好的商店，或者直接从远东购买这些简单的转换器。

## 协议

到目前为止，I2C 听起来有点棘手，但是真正棘手的部分都发生在协议层。首先，数据线总是在时钟线为低电平时建立，并且可以在时钟线为高电平时读出。(这个定义消除了 SPI 的相位/极性问题，以及异步串行的电压反转问题。)这个规则有两个例外:如果数据线随着时钟高电平从高电平转换到低电平，这是一个*开始*信号，如果数据在高电平时钟期间转换到高电平，这是一个*停止*。每笔交易都以*开始*信号开始，以*停止*结束。原则上，这让线路上的每个设备都知道对话正在进行，并告诉它们在看到*停止*之前不要开始自己的对话。

[![Image Marcin Floryan. https://en.wikipedia.org/wiki/I%C2%B2C#/media/File:I2C_data_transfer.svg](../Images/31f17482edddfbf26c1d279eef175e5e.png)](https://hackaday.com/wp-content/uploads/2016/07/i2c_data_transfer.png)

Image: [Marcin Floryan](https://en.wikipedia.org/wiki/I%C2%B2C#/media/File:I2C_data_transfer.svg)

因为所有的设备共享相同的两条线路，所以它们需要地址。此外，从设备需要知道它们是否应该在单线上发送或接收数据。在开始信号之后，任何事务的第一个字节是一个 7 位地址和一个单向位，它告诉从机是期望*读取*还是*写入*数据。例如，对于 LM75 温度传感器，您可以通过发送器件地址(本例中为 48 美元)和设置为 1 的最后一位来读取数据，从而读取两个字节的温度值。然后，主机发送两个字节的时钟，在此期间接收数据，然后发送停止信号。还有一个复杂的问题。

[![Transaction detail from Maxim's LM75 datasheet](../Images/f6cf4100e2db59c86943f2ef420aa240.png)](https://hackaday.com/wp-content/uploads/2016/07/lm75_ack.png)

Transaction detail from Maxim’s LM75 datasheet

在 I2C 线上发送的每个字节都会被刚刚接收到最后一个字节的一方(从机或主机)确认(肯定或否定)。它的目的是让设备说“好的，我知道了，继续”。因此，当主机从从机读取字节时，主机会在发送下一个字节之前应答每个字节。如果主机正在向从机写入字节，则从机必须做出应答。拉低数据线的低电平是正`ACK`信号，意味着一切正常。

否定应答(`NACK`)信号让事情变得更加复杂。根据上下文，它可能意味着“我还没准备好”或“那没有意义”，甚至是“我现在已经完成接收了”。由于这种多种可能的含义，当从从机读取数据时，必须仔细阅读数据手册，因为主机需要知道何时`ACK`和何时`NACK`。

例如，当 LM75 温度传感器处于最简单模式时，主机发送地址和一个读取位，然后读回两个字节。因为主机发送了地址，所以从机确认说它准备好了。然后从机发送一个字节，主机用`ACK`应答。然后从机发送第二个字节，主机用一个`NACK`和一个停止信号来响应，说它完成了。

```
Master: Start Signal
Master: Address + Read Bit
Slave:  ACK
Slave:  First byte of data
Master: ACK
Slave:  Second / last byte of data
Master: NACK
Master: Stop Signal

```

总结协议，还有多方通信。例如，如果主机需要向从机发送一个字节，然后读回一些字节，它需要首先用写信号发送地址，然后用读信号重新发送地址。为了发出模式改变的信号，主机发送所谓的“重复开始”信号，这只是在没有先前停止时的常规开始信号。同样，这里有一个 LM75 的例子，首先告诉想要读取高温设置的 LM75，然后读回两个字节。

```
Master: Start Signal
Master: Address + Write Bit
Slave:  ACK
Master: Set the high-temperature register for reading
Slave:  ACK
Master: (Re-) Start Signal
Master: Address + Read Bit
Slave:  ACK
Slave:  First byte of data
Master: ACK
Slave:  Second / last byte of data
Master: NACK
Master: Stop Signal

```

注意，在这两个例子中，当主机从从机读取任意数量的数据时，最后一个字节用`NACK`来“确认”。这并不意味着它丢失了一个字节，而是向从机发出信号，表明它不再请求任何数据。这是一个“都完成了！”信号。如果你在通电后第二次传输有问题，看看你是在最后`NACK` ing，否则从机可能会混淆。

## 调试帮助

关于`ACK`和`NACK`的整个事情会变得棘手，这肯定是错误的来源之一。另一方面，应答位提供了一点信息(嘻嘻！)关于沟通进展如何。

### 总线 Pinging

在协议级调试 I2C 系统时，要做的第一件事是确保从设备在那里并在监听。由于从机应该在听到其在数据线上的地址后以 ACK 响应，因此这可以用来确定其范围。这应该是您调试 I2C 设置的第一站:如果从设备甚至不知道它的地址，您可能遇到了布线问题。

[![bus_scan](../Images/a580dfef8637a71e31c564cbeccfa11e.png)](https://hackaday.com/wp-content/uploads/2016/07/bus_scan.png) 因为一条常规的 I2C 总线上只有 127 个可能的地址，这可以推广到检查总线上的所有设备。一个 [I2C 总线扫描](http://hackaday.com/2015/06/25/embed-with-elliot-i2c-bus-scanning/)简单地通过每个地址，并打印出哪个地址导致一个`ACK`。这是一个很好的检查，以验证每个设备的地址是你认为它应该是什么。总线扫描和验证可能属于任何严肃的 I2C 系统的通电自检。现代 I2C 芯片也有一个可以读出的芯片 ID 字段。如果有就用吧。

### 检查

我将第一个承认，当一切正常时，我通常会扔掉那些`ACK`部分。当 I2C 设置运行时，它只是浪费 CPU 周期来测试它的每个字节。另一方面，当事情不顺利时,`ACK` s 就是一笔财富。通过读取`ACK` s 来跟踪非工作的多字节通信，可以让您知道事情何时变糟。

如果你使用的是 AVR 芯片，看看他们的“双线接口”(这是 I2C，但不侵犯飞利浦/NXT 的商标名称)的数据表。硬件 I2C 模块几乎每一步都有一个状态代码，包括测试预期的`ACK`等。我相信其他芯片也会做类似的事情。如果遇到问题，请检查每个字节后的状态码，并将其与器件数据手册中的信号图进行比较。你会把它弄清楚的。

## 零碎东西

正如目前所描述的，I2C 相当复杂，有许多困难要克服，也有很多漏洞可以钻进去。情况变得更糟。

### 地址冲突

虽然拥有一个能够容纳多达 127 个设备的地址空间听起来很酷，但现实是任何 I2C 总线可能只有少数几个连接起来。这有两个原因。首先，总线上增加的每个器件都会带来一点寄生电容。第二个是设备地址并不完全灵活，它们甚至会在不同的 IC 之间发生冲突。

[![Three Address Pins: Maxim's LM75 Datasheet](../Images/8ba2c5bb0613a5729324561ae7301bb8.png)](https://hackaday.com/wp-content/uploads/2016/07/address_pins.png)

Three Address Pins: Maxim’s LM75 Datasheet

再次以 LM75 为例，所有芯片在出厂时都有一个硬编码的十六进制基址`0x48`。它们还有三个引脚，当接地或上拉至电源电压时，通过将三条线的二进制值加到`0x48`上，可以指定多达八个可能的地址。这意味着你的巴士上一次只能有八架 LM75s。句号。不是 127。

如果它们的地址重叠，你也不能使用不同的芯片。例如，恩智浦的 [PCF8563 RTC 芯片](http://www.nxp.com/products/interface-and-connectivity/interface-and-system-management/isup2-supc-bus-portfolio/isup2-supc-real-time-clocks-rtc/real-time-clock-calendar:PCF8563)有一个读写地址，这两个地址都与 [24C32 EEPROM](http://www.futurlec.com/Memory/24C32pr.shtml) 的八个可选地址中的两个相冲突。很多年前，Adafruit 开始记录这些地址，并[制作了一份总清单](http://www.ladyada.net/library/i2caddr.html)。不幸的是，看起来他们也很久以前就放弃了。您需要自己阅读数据手册，避免地址冲突。

寻址问题的一个可能的解决方案是扩展的 10 位寻址，它在 1992 年作为标准被采用，但是我仍然没有看到那么多的设备使用它。(可能是我吧。)该方案使用固定的 5 位前缀(`0b11110`)，后跟两个地址位和第一个字节中的读/写位，然后是第二个字节和地址的剩余 8 位。1，024 个地址对于整个 I2C 设备世界来说应该足够了，对吗？

### 多母盘制作和时钟拉伸

这就是事情变得非常棘手的地方。由于 I2C 信号线的下拉、浮动行为，两个器件有可能同时发送相反的信号。(低者胜。)原则上，这可以用来在两个不同的方向上扩展功能。如果一个器件期望在`SCK`或`SDA`上发送一个高电平信号，但是线路被另一个器件拉低，那么一定有问题。

#### 时钟拉伸

[![](../Images/124ee969adbde70a05a148973762e1af.png)](https://hackaday.com/wp-content/uploads/2016/07/clock_stretch1.png) 如果一个从机正在拉下时钟，这被称为“时钟拉伸”，是给主机暂停的信号，直到从机准备好。原则上，主设备不应该发送，直到它注意到从设备已经释放了线路，并且它浮动回来。当然，这依赖于主机在认为它让线路浮高时检查低信号。如果你正在使用一个著名的微控制器的 I2C 硬件，你可能处于良好的状态——它会检查时钟线。如果你正在使用一些在被请求时不会暂停的 I2C 例行程序，你将会丢失数据。

当线路由于时钟拉伸而停滞时，可能会出现更微妙的问题。原则上，任何从机都可以通过拉低来延长时钟，并且可以无限期延长，主机必须尊重这一点，在从机释放时钟线之前，不得发送新数据。在最好的情况下，这可能会对总线上需要按计划发送的数据造成严重破坏。在最坏的情况下，只需将时钟线拉低，就可以有效地控制整个总线。

EEPROMS 或闪存等设备是臭名昭著的时钟拉伸器。他们通常以页为单位写入数据，写入数据需要有限的时间。因此，它们会以你能传输的最快速度接收 64 个字节，但当它们到达页面边界并需要写出时就会停止。小心这些芯片！其他 EEPROMS 有双缓冲器，基本上避开了这个问题，读入一个，同时写出另一个。

#### 多主仲裁

I2C 标准允许多个时钟主机轮流在总线上工作。理想情况下，每个潜在的主机都在跟踪开始和停止信号。当线路空闲时，它可以开始传输。但是当两个主人决定立刻开始时会发生什么呢？

他们“仲裁”。如果一个主测试线，当它应该是高的时候，发现它是低的，这是一个信号，线根本不是自由的。所有目前没有拉下线的设备都应该停止传输。其思想是，在地址完成之前，所有冲突的主机都应该已经后退。不用说，将支持和不支持多主机的设备混合在一起会导致灾难。

### 解决方法

如果你愿意，可以说我是懦夫，但是我解决多重控制和时钟拉伸问题的方法是避免它们。这意味着使用多个 I2C 公交网络。到目前为止，最简单的方法是购买一个内置了不止一个硬件 I2C 控制器的微控制器。

增加第二条 I2C 总线也有助于隔离一个流氓时钟展宽器，它阻塞了其他时间关键的传输。为低延迟传输保留一条总线，并将时钟延长器隔离到它们自己的总线。或者，如果你运行的是混合芯片——一些芯片的运行频率只有 100 kHz，而另一些芯片的运行频率为 400 kHz 或更高——运行快速总线和慢速总线将使你获得最大速度，而不会混淆慢速总线。更多的总线意味着更多的灵活性。

但是如果你真的需要在一条总线上用相同的地址控制大量的 I2C 设备，解决方案是 I2C 多路复用器。这些特殊的芯片可以让你从一个 I2C 端口运行 16 个地址相同的设备，方法是从 CPU 中选择更多的线路。这是特殊的情况，对于特殊的雪花。

## 故障排除清单

如你所见，I2C 发生了很多事情，也出了很多问题。I2C 调试无法与玫瑰上的雨滴或小猫的胡须相提并论。

*   在开始之前，给自己泡一杯镇静的茶或其他饮料。
*   仔细检查接线。`SCK`和`SDA`混在一起了吗？电压水平是否正确/相同？
*   对于最慢的从机，你是否以正确的速度运行总线？上拉足够强吗？用示波器验证速度和波形。
*   你能从你的目标设备上得到初始的`ACK`吗？做一次巴士扫描。
*   还是不及格？将除目标设备之外的所有设备从总线上断开，并使初始`ACK`工作。逐一添加其他设备。这有助于找到巴士猪。
*   一旦初始的`ACK`开始工作，使用它们来逐步完成事务的剩余部分，一次验证一个字节。
*   您是否为每个事务正确设置了读/写模式？
*   各方都在该做的时候做了吗？有时你会看到主设备释放线路和从设备发出`NACK`之间的小故障。这很正常，实际上是一切正常的标志。
*   如果您切换读/写方向，您是否会再次发送重启和地址？设备支持这个吗？
*   仔细检查数据手册中的地址冲突。扫描总线，确保看到正确数量的设备。
*   你在多掌握总线吗？你能轻易避免这样做吗？
*   如果你需要排除一个*真正*棘手的问题，在总线上所有芯片的输出上放置[不同值的电阻。每个芯片的低电压值会略有不同，让您可以在示波器上看到哪个芯片在任何给定的时间进行通话，并在它们相互通话时进行诊断。](http://www.i2c-bus.org/i2c-primer/serial-resistances-and-debugging/)

祝你和 I2C 好运！如果你有任何其他具体的问题或解决方案，请在评论中告诉我们。另外两篇文章得到了很好的回应。*