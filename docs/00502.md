# 你的第一个带 SDRPlay 的 GNU 收音机

> 原文:[https://hack aday . com/2015/11/12/your-first-GNU-radio-receiver-with-SDR play/](https://hackaday.com/2015/11/12/your-first-gnu-radio-receiver-with-sdrplay/)

虽然 GRC(GNU Radio Companion)使用了 Radio 这个词，但它实际上是一个用于构建 DSP 应用程序的图形化工具。在上一篇文章中，我向您展示了如何通过使用声卡(甚至更少)来进行[实验。然而，谁能抗拒通过在电脑屏幕上拖动积木来建造一台真正的收音机的诱惑呢？](http://hackaday.com/?p=175516)

对于这篇文章和附带的视频，我使用了一个 [SDRPlay](http://hackaday.com/2015/09/25/mid-price-hardware-gets-serious-about-software-defined-radio/) 。这个小黑盒一端有天线插孔，另一端有 USB 端口。您可以要求它提供有关 RF 频谱特定区域的数据，它会以 GRC(或其他 DSP 工具)可以处理的形式发送复杂的(IQ)数据。

SDRPlay 很划算(约 150 美元)，但如果你不想投资 SDR play，还有其他选择。有些价格差不多(比如 HackRF 或 AirSpy ),但功能不同。然而，你也可以使用便宜的[电视加密狗](http://hackaday.com/2012/04/13/those-usb-tv-tuners-used-for-sdr-can-also-grab-gps-data/)，有一些限制。重新设计的加密狗没有那么敏感，在没有外部帮助的情况下不会在较低的频率下工作。另一方面，它们非常便宜，所以你可以忽略一些小皱纹。你不能指望从更贵的 SDR 盒子中获得更高的性能。有些人会增加放大器和转换器来解决这些问题，但在某种程度上，购买更贵的转换器会更划算。

 [https://www.youtube.com/embed/m0GGBFBWFfU?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent](https://www.youtube.com/embed/m0GGBFBWFfU?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent)

T2】

## 传统无线电架构

![[Billy Cheung's] matchbox crystal radio which we covered in September](../Images/dda37658c796876a96400ec9dc135b4f.png)

【Billy Cheung 的】火柴盒水晶收音机我们在 9 月

讨论 SDR 之前，回顾一下一些传统的无线电接收机架构很有用。许多人小时候都做过水晶收音机，所以让我们从那里开始吧。水晶收音机有一个大线圈和某种电容器，可以选择特定的无线电频率。通过选择，我的意思是它将挑选出某个频率，并拒绝其他频率。唯一的问题是，它不太擅长这样做。它不会完全拒绝你不想要的频率，也不会让任何信号变强——事实上，即使是选定的频率也会变弱。这是你为一个简单的接收器付出的代价。

调幅收音机通过改变载波的振幅来传送调制信号(在这种情况下就是声音)。二极管可以恢复变化的幅度，晶体收音机可以使用锗二极管、方铅矿晶体(因此得名)，甚至剃刀片和安全别针。信号不会很强，但高阻抗耳机将工作，或者你可以建立一个简单的音频放大器。

有很多方法可以改进简单的晶体收音机，但它们都有相似的目标:增强信号强度，或提高对无用信号的抑制(或两者兼而有之)。例如，调谐射频(TRF)收音机在二极管检波器之前使用调谐放大器，有选择地加强你想听到的信号。

## 超外差的

![Superheterodyne build we covered in March](../Images/81989a4d8126aa7a325047605b4493cb.png)

Superheterodyne build [we covered in March](http://hackaday.com/2015/03/08/simple-superheterodyne-sw-receiver-harks-back-almost-100-years/)

TRF 的问题是你必须把每一级调到你想要的频率。这个问题导致了最常见的接收器类型的发展:超外差式。在这种方案中，输入信号可以被选择和放大，但是随后它与本地振荡器混合。混频器将从信号中增加(和减去)本地振荡器频率。

假设我们收音机的输入有两个信号:一个在 7050 千赫(我们想听到的)，另一个在 7200 千赫。进一步假设本地振荡器设置为 6050 kHz。混合后，您将获得 1000 kHz、1950 kHz、13100 kHz 和 13250 kHz 的信号。为什么这很重要？因为我们现在可以构建高度调谐的放大器，放大 1000 kHz(称为中频或 IF)的信号，并抑制其他信号。

好处是那些调谐放大器不用调。这意味着它们更容易操作，也更容易制造得非常高效。例如，好的收音机可能使用晶体滤波器来抑制所有额外的频率。对于传统收音机来说，这是创建实用滤波器的最佳方式。解调后，收音机可能会放大音频信号，以驱动扬声器或耳机。

概括来说，基本布局是 RF 前端、混频器和本振、IF 放大器和滤波器、解调，最后是音频放大。请记住这一点，因为许多相同的片段会以某种形式出现在软件无线电中。

使用软件定义无线电，您通常会有相同的目标，但您不会以相同的方式完成它们。IQ 数据输入并代表整个可用信号。在某些情况下，你必须像在模拟收音机中使用混频器一样改变频率。然而，对于 SDRPlay，信号已经以零频率进入。使用 GRC 进行滤波的方法有很多种，因此很容易切断您不关心的频率(如果您需要，一些滤波器也可以转换频率)。

## 取样率

软件定义无线电最重要的一点是采样速率。如果你想要 1 MHz 的带宽，你至少需要 2 MHz 的采样频率。然而，当你试图进行复杂的处理，甚至只是想去音频，你会希望削减到更窄的频带和采样速率。

GRC 模块使用两个 DSP 术语来调整采样速率:抽取和插值。将信号抽取 4 倍实际上就是将采样速率除以 4。插值 2 将使表观采样速率加倍。您通常会使用这两种方法来获得采样速率的非整数变化。例如，要从 1000 kHz 到 44.1 kHz，不能只除以一个整数。但是你可以用 441 插值，用 1000 抽取来得到你想要的结果。

## 简单的无线电接收器

[![block1](../Images/e018d7a364410ef62254f79696d1273a.png)](https://hackaday.com/wp-content/uploads/2015/10/block1.png) 让我们来看一个简单无线电的流程(与上面视频中看到的相同)。与前一篇文章中的例子不同，我使用了 WX GUI 系统，但是同样的原理也适用于 QT 库和块。最重要的模块是 Osmocom 模块(见右图)，它连接到 SDRPlay 盒。该模块的属性设置接收频率、带宽和 RF 增益。SDRPlay 上的 RF 增益配置可能有点挑剔。如果声音太低，你什么也听不到。但是如果太高，你就会超速，造成失真。

我将 Osmocom 模块的输出连接到两个不同的模块串。一个分支就是 FFT，这样你就可以看到 SDRPlay 被调谐到的附近的所有活动。另一个分支负责像常规收音机一样工作。因为 SDRPlay 数据已经转换到零频率，所以没有必要这样做。然而，截止目标频率以上的频率是有好处的。

[![block2](../Images/d5bd2c7768c992a4b44f29b352745508.png)](https://hackaday.com/wp-content/uploads/2015/10/block2.png) 左边的低通滤波器负责滤除 5 kHz 以上的信号，这对于 AM 信号来说是足够的带宽。此外，我让滤波器将信号抽取 32 倍。记住，我们需要把声卡的频率调到 48 kHz。在这里抽取样本将使以后进一步划分样本更容易，并提高 CPU 利用率。低通滤波器之后的级是一个合理的重采样器。该模块对采样速率进行分频(抽取)和乘法(插值),允许您将采样速率乘以一个分数。

重采样器的输出为 48 kHz，并馈入自动增益控制模块和解调器。你会注意到解调器的输出端口是橙色的，表明它是一个实数流，而不是 IQ 样本。音频接收器是 PC 扬声器的网关，但在数据到达之前，收音机会将其乘以一个值。默认值为 1，因此没有影响，但是 GUI 音量控件可以将该值设置为不同的数字，以调整音频信号的幅度(即音量)。

将此映射回传统的超外差架构，您可以将 Osmocom 模块视为前端、本地振荡器和混频器。它与解调器之间的级类似于传统接收机的 IF 级。通过解调器的一切与普通收音机的模拟放大器没有什么不同。

## 收音机 GUI

说到 GUI，这个例子和上一个例子都使用了一些 GUI 控件来改变音量和频率。每个 GUI 块都有一个 GUI 提示，您可以使用它来控制它在运行的收音机中的显示位置。每个提示可以使用两个或四个数字。前两个数字是行和列(都是从零开始的)。你可以想象一个你需要多少行和列的虚拟网格。

如果你用四个数字，前两个是一样的。但是，第二对数字指定要扩展多少列和多少行。因此，例如，如果第一行在它们自己的列中有三个控件(提示[0，0]、[0，1]和[0，2])，通过在提示中指定[1，0，1，3]，可以让控件在第一行中跨越整个窗口宽度(没有括号，括号只是为了可读性)。你会在视频中看到一个例子。此外，下图显示了无线电的一部分，说明了顶部 FFT 如何跨越 5 行 4 列。请记住，行和列都是从零开始的，所以下一个空行是第 5 行，显示频率的两个控件出现在第 5 行(第 1 和第 3 列)。

![radiogrid](../Images/f30ff5faa2e989c16a6331fa7898a0b7.png)

如果你跟随视频，你会发现用 GRC 创建一个简单的收音机是相当容易的。显然，你可以通过改善收音机接收效果和增加 FM 接收等功能来改进设计。不过，我的目标是创建一个基本的设置，您可以在着手更复杂的项目之前尝试在此基础上进行构建。

您可以从 Hackaday.io 上的项目页面[下载示例文件。您可能需要根据您的 SDR 适配器和声卡进行一些调整，但是如果您有支持 48 kHz 采样的 SDRPlay 和声卡，您应该可以开始了。](https://hackaday.io/project/8277-gnu-radio-examples)

如果你正在寻找一个实际的项目，考虑一下这个:你能用一个 [RTL 加密狗](http://hackaday.com/2013/01/12/listening-in-on-weather-balloons-with-rtl-sdr/)做的任何事情，你应该能用 SDRPlay 做。如果你搜索我们过去的帖子，你会看到[许多基于这个廉价设备的 SDR 项目](http://hackaday.com/2013/09/09/an-rtl-sdr-spectrum-analyzer/)。