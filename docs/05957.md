# 用微控制器读取宾果球

> 原文:[https://hack aday . com/2017/06/07/reading-bingo-balls-with-micro controllers/](https://hackaday.com/2017/06/07/reading-bingo-balls-with-microcontrollers/)

每隔一段时间，一个项目就会伴随着那种神奇的力量来消耗你好几个月的时间和注意力。当你最终完成它的时候，你感到遗憾的是你不必再做任何事情。

这个宾果球阅读器有什么特别之处？乍一看，这似乎是一个普通的 OCR 项目；相机捕捉图像，OCR 软件识别号码。就这么简单。它工作起来没有任何问题，就像每个简单的小工具一样。

不过话说回来，可能也没那么简单。数字分散在整个球上，所以必须先定位，必须选出最佳的阅读候选。然后，数字被画在一个球体上，而不是一个平面上，有时会使它们变形到必须首先恢复形状的程度。此外，阅读的角度不是固定的，而是在 360 度的范围内。此外，我们还有眩光问题，因为宾果球如此闪亮，以至于每个光源都反射出饱和的亮点。

就这些吗？嗯，差不多了。这项任务应该由嵌入式微控制器执行，速度和内存都有限，但对一个球的识别过程必须很快——最差也要 500 毫秒。但这只是过程的一部分。该项目包括流水线机制，该机制接收球，将其传送到 OCR 进行扫描，然后在球被丢弃之前由公共广播摄像机拍摄。最后，如果读数不够可靠，就必须微妙地旋转球，以便重新定位数字，进行另一次读取尝试。

尽管有这些挑战，我还是设法建立了这个系统。它又快又可靠，在这个过程中我发现了一些非常有趣的技巧。看看下面的快速演示视频，感受一下速度，以及系统“看到”了什么。然后在休息之后和我一起深入了解这个有趣的嵌入式构建的细节。

 [https://www.youtube.com/embed/53D_fnK2Kec?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent](https://www.youtube.com/embed/53D_fnK2Kec?version=3&rel=1&showsearch=0&showinfo=1&iv_load_policy=1&fs=1&hl=en-US&autohide=2&wmode=transparent)

T2】

最初，我认为我必须采用一个神经网络来进行识别过程，但事实证明，识别实际上是项目中最简单的部分，从算法上来说，这将更加容易和快速。困难的部分是确定什么是整个图像上的什么，定位最好的数字，它下面的线，并测量它应该旋转多少。从位图图像开始，处理器必须做大量的数学运算，甚至在它能确定数字是由一个还是两个数字组成之前。

[![](../Images/4ce1b140890f523d1614aa77b7171a6a.png)](https://hackaday.com/wp-content/uploads/2017/06/bingo-ball-scanner-schematic-themed.jpg)

Simplified schematic of OCR section

### 开发期间的 VGA

为了使开发、维护和调整更容易，除了图像获取和处理之外，相同的 MCU 还用于 VGA 信号产生。它不仅显示扫描图像，还包括一些当前参数和 RAM 内容。控制器板有一个 VGA 连接器，但在设备正常运行时不应使用。VGA 监视器与宾果大厅中的广播监视器没有任何共同之处，因为有两个独立的摄像机和照明系统。

VGA 信号产生会消耗大量处理器时间，因此在图像获取和处理期间会关闭，在每个读球周期中大约需要 500 ms。同步信号由内部 PWM 外设透明产生，并且始终有效，因此 RGB 信号建立后图像恢复速度很快。

在这种情况下，使用 16 位微控制器 PIC24EP512GP806，具有 586/52 K 的程序/数据存储器和 60 MIPS 的执行速度。

### 获取图像

低成本的模拟“立方体”相机在开发的第一阶段使用，但后来被数字立方体相机取代。两者在价格和性能上相似，但后者配备了焦距更长的镜头，因此距离可以更远，相机可以看到球的更大区域。

对于这样一个小物体来说，最好的光源应该是白光 led，但对于闪亮的球表面来说，眩光非常糟糕。我用扩散器做了一些实验，但是运气不好。最终的解决方案来自一个完全不同的方法:非常明亮和清晰的反射，但使用不同光源的双重曝光。在第二次图像获取过程中，MCU 为每个像素选择较低的值。

![](../Images/2ff37f571558ca4b1b198c64795a9ebc.png)

由于热点从不匹配，它们将被取消，结果图像(左起第三张照片)是均匀照明和无眩光的。作为一个额外的奖励，背景光反射在这个过程中也被取消了。

请注意，该系统是嵌入式的，没有截图功能，所以图像来自用相机拍摄的 VGA 显示器。

光源由 16 个白色发光二极管组成，因此一次有 8 个发光二极管工作。最右侧的图像代表从相机角度看的 LED 排列。led 在这里被染成红色和蓝色，以帮助区分第一次和第二次曝光的组。

这使得该过程明显变慢，因为现在我们不仅有两次曝光，还有两次曝光之间的虚拟帧时间，以允许 CMOS 传感器在光照变化后恢复和适应。这就是为什么整个成像过程几乎需要 100 毫秒。

扫描图像的分辨率为 220×220 像素，像素深度为 8 位。模拟灰度图像仅由六位组成，剩余两位用于显示器上的蓝色和红色，因为灰度实际上是绿色。这些额外的像素用作处理步骤之间的特殊标志像素，在单步模式下显示为蓝色和红色区域。这在程序开发和调试过程中非常有用。

整个过程分为 17 个步骤，出于开发和调试目的，也可以单步方式执行。步数显示在屏幕的左上角(见下图)，分辨率为 1 ms 的秒表的当前状态显示在右上角。这样就很容易跟踪执行时间并优化每一步。

### 球的位置和伸展

为了精确定位球，使用公式`Cx = ∑CixAi / ∑Ai`和`Cy = ∑CiyAi / ∑Ai`计算质心(几何中心)的 X，Y 坐标，其中 Cx，Cy 是 X，Y 坐标，A 是每个像素的值。因为在这一步之前背景主要是黑色的，所以 Cx，Cy 将大约在球的中心。然后，将整个帧缓冲器作为 2D 块移动，使得质心位于坐标 X=110，Y=110，这是帧的中心。中心用 2×2 红色像素(位 7)标记只是为了方便开发人员，因为处理固件在大多数情况下会忽略位 6 和位 7。

接下来，测量球直径，计算不同直径周长上的平均像素值。然后，背景(直径之外的每个像素)被设置为“白色”，或者更具体地说，设置为绿色(值 0x3F)，以确保更好地隔离黑色区域。在处理过程中，每次需要选择黑色(油墨)或白色(纸张)区域时，背景将被设置为白色或黑色多次。

![](../Images/da9bc80ca47def325252c2c8b7990b74.png)

完美地将球体转换成平面是不可能的，但是如果图像是非线性变形的，形状可以得到改善，就像步骤 3 中的图像一样。小型 16 位微控制器没有算术协处理器，使用标准三角函数库会消耗太多处理器时间。这就是使用三角查找表的原因，您可以在秒表(右上角的蓝色数字)上看到，在这种情况下，拉伸程序的执行时间仅为 11 ms。您还可以看到，球的中心部分基本上没有变化，边缘被非线性拉伸，从而将球形变形降至最低。

第四步，类似于 Photoshop 中的反锐化掩模功能，创建一个新的模糊图像。由于没有足够的 RAM 空间用于另一个完整的帧缓冲区，因此对缩小到 44×44 分辨率的辅助图像执行该操作。模糊蒙版的功能非常重要，因为它可以确保相对于“纸张”像素更好地选择“墨水”像素。选择意味着“设置第 7 位”，这将导致 VGA 屏幕上出现红色区域。

现在在同一个帧缓冲器中有两个图像，灰度图像(位 0-5)和二进制图像(位 7)。后者用于预处理步骤 6，在该步骤中消除小孔和划痕。首先扩展和收缩选定的图像，然后以相反的操作顺序重复该过程，这将导致边缘平滑变圆且无垃圾。

### 组件操作

在几个预处理步骤之后，会发生更严重的操作。第一种称为“连接组件”，选择隔离区域并获取每个区域的参数。这包括 X 和 Y 维度、X 和 Y 中心坐标、选定的像素数以及欧几里德距离框架中心的距离。这将有助于将每个组件分类为数字、大圆、下划线或背景。在这个阶段，数字是包含一位数还是两位数也变得很清楚。

这一步需要大量的处理时间，大约 200 ms。另一个问题是，连接组件的标准算法需要一个相同大小的辅助帧缓冲区，因此我必须创建一个新算法，利用相同的帧缓冲区，外加一个临时坐标的小表。

在这一点上，处理器很容易选择识别的最佳候选——它是从球的中心到欧几里得距离最小的圆。这个圆内的连通分量被考虑在内，其他的都被删除。

![](../Images/1fad645a1dd522e628bf3dd906064be1.png)

问题中的球是带有下划线数字的特殊 OCR 球，以便可以测量旋转角度。现在圆心已知，程序围绕 360°圆旋转虚拟“T”形(对应于下划线形状)512 步，计算它包含多少个“墨迹”像素。最高额定计数指示旋转角度，然后帧缓冲区的 2D 块被移动到图像的右下角(最左边图像上的步骤 12)，并且旋转被执行，位图被移动到帧缓冲区的对角。多亏了对数查找表，这组操作只需要 50 毫秒。

每走一步都会越来越好。用不同的颜色选择数字，然后将一个数字移动到安全距离，然后将每个数字缩放到 30×46 的已知分辨率。

### 承认

由于这个阅读器是我的第一个 OCR 项目，我天真地认为识别过程将是最难解决的部分。每一步都经过充分调试，逐一检查后，我到了第 17 步，也是最后一步。正如我已经指出的，我最初的计划是建立一个神经网络，但后来我尝试了一个简单的算法，并对它进行了试验。我用几个球测试了它，你无法想象当我看到它完美地工作时我有多震惊！最后，位图被正确地转换成两个 ASCII 码。

算法很简单。每个数字的位图实际上被分成三部分，首先是水平的，然后是垂直的。然后计算每一列或每一行的有效像素，并生成直方图。还有一个附加的第 7 直方图，它是倾斜的，以帮助更好地检测数字 4 和 7 处的横切线。

为每个数字构建七个直方图，并与预先录制的表格进行比较，计算均方误差的总和并对结果进行排序，只需 3 毫秒。为了使开发和调试更容易，所有直方图都绘制到屏幕上。

在比较结果排序后，我们得到了每个数字的获胜者(在本例中是 8 和 5)，但是我们的工作直到另一件事情发生才完成。必须对读数的质量进行评级，以便控制器可以评估结果是否足够可靠。

如果球上的数字只有一个数字，则对每个数字(0…9)的误差表进行排序，并将“获胜者”与第二个数字(接近获胜者)进行比较。如果比率高，则意味着识别成功。在我们的例子中，它是 147%，这意味着第二等级的候选人比最好的候选人多 147%的错误。例如，第一个有 100 个“错误单位”，第二个有 247 个。这是一个很好的评级，尽管大多数评级都在 300%以上。通常，高于 80%的评级应被视为足够安全。

但是如果有两位数呢？一条链的强度取决于其最弱的一环，因此程序将忽略更成功识别的数字(比率较高的数字)，并使用较弱的数字来做出成功的最终决定。

控制器有两种基本操作模式。在快速模式下，只有一个读数，只有在第一个读数不够好的情况下才会重复(在球旋转之后)。在较慢(“安全”)模式下，有两个读数的结果必须匹配。

阅读器在贝尔格莱德生产赌场设备的 Eleks-M 公司进行了测试。使用一个额外的静态照相机进行测试，该照相机自动记录每个球读数，然后将图像(文件名只包含识别的球号)按字母顺序排序，并手动进行最终检查。

整个测试持续了 240 个小时，这将有助于对 Bingo 吹风机和阅读器的耐用性进行压力测试。在 10 天读取 115，000 个球之后，只有一个错误的读数(球 37 被读取为 7)，读取器被设置为快速模式。在安全模式下测试是没有意义的，因为错误可能永远不会发生。

### 机械概念

![](../Images/bed08357fb8cd9ee19930fa0959b589f.png)宾果球的物理路径是圆形的，步进电机在每个球循环中将转盘旋转 90°。有四个流水线步骤:球进、OCR 读取、广播记录和球出。宾果鼓风机几十年来一直遵循相同的功能模式。在过去，球是人读的(可能来自广播摄像机)，然后我们得到条形码(左)，然后是 RFID 阅读器(中)，最后是光学字符识别(右)。

另外还有一个步进电机，它在扫描后旋转 OCR 相机下的球，以便在需要再次读取时做好准备。控制器包含两个相等的 MCU:一个扫描图像，识别数字，控制 LED 照明并产生 VGA 信号，另一个驱动步进电机，与服务器通信并控制鼓风机的所有部件。

外壳和机械部件由 FR4 制成，使用我之前的指南中描述的[工艺。唯一的例外是旋转木马，它是由激光切割丙烯酸制成的。主步进电机直接旋转转盘，四个磁铁和一个霍尔传感器负责原位定位。](http://hackaday.com/2015/06/03/how-to-build-beautiful-enclosures-from-fr4-aka-pcbs/)

如果控制器决定有必要再读取一次，小型步进电机会轻微转动小球，以重新定位数字。控制器还可以控制鼓风机单元内部使用的第三步进电机，以在游戏开始时打开入口门。

![](../Images/d6edf3608c13170d3eb8e5e56022f73a.png)

为了使装置更紧凑，控制板连接到外壳上，因此仅有的外部电缆是 12 VDC 电源和 RS232，用于与服务器通信。对于非常长的距离，有一个电流隔离的电流环路。还有一种 USB 版本的控制器，但电缆的长度有限，在某些情况下很难实现。

[![](../Images/3db6619dd33f3c0d0ff8e04d649566b8.png)T2】](https://hackaday.com/wp-content/uploads/2017/06/pcb.jpg)

该项目的两个旧版本在

*   [https://hackaday.io/project/5649-ocr-for-bingo-balls](https://hackaday.io/project/5649-ocr-for-bingo-balls)
*   [https://hack aday . io/project/11515-optical-bingo-ball-reader-assembly](https://hackaday.io/project/11515-optical-bingo-ball-reader-assembly)。

最后，固件(仅用于 OCR 微控制器)使用了近 80 K 字节的查找表和大约 6000 行汇编语言代码，不包括注释。你没听错——都是汇编语言。我是个硬件爱好者，我喜欢让一切都在我的掌控之中。

我忘了再补充一点，但是你现在可能已经猜到了:做这样的项目是一个爆炸。