# 对浮点数的改进

> 原文:[https://hack aday . com/2015/10/22/an-improvement-to-floating-point-numbers/](https://hackaday.com/2015/10/22/an-improvement-to-floating-point-numbers/)

1991 年 2 月 25 日，在伊拉克入侵沙特阿拉伯的前夕，一枚从伊拉克阵地发射的飞毛腿导弹击中了沙特阿拉伯达兰的美军军营。防御是可行的——爱国者导弹在今年早些时候拦截了伊拉克的飞毛腿导弹，但不是在这一天。

控制达兰爱国者导弹的计算机在导弹发射时已经运行了 100 多个小时。这台计算机的内部时钟被乘以 1/10，然后被塞进一个 24 位的寄存器。1/10 的二进制表示是非终结性的，将其削减至 24 位后，会产生一个小误差。这种误差每秒钟都在轻微增加，100 小时后，爱国者导弹系统的系统时钟就差了 0.34 秒。

飞毛腿导弹的速度约为每秒 1600 米。在三分之一秒内，它运行了半公里，远远超出了爱国者跟踪的“距离门”。1991 年 2 月 25 日，一枚爱国者导弹未能拦截向美国军营发射的飞毛腿导弹，造成 28 人死亡，100 人受伤。这是浮点错误第一次导致死亡，当然也不会是最后一次。

浮点数和数字计算机一样早就存在了；第一台二进制可编程机械计算机 Zuse Z1 使用 24 位数字表示，包括一个符号位、一个 7 位指数和一个 16 位有效位，这是当今浮点格式的前身。

尽管有这么长的历史，浮点数还是有问题。糟糕的实现可能会产生小的编程错误。floats 不保证不同计算机上的答案相同。浮点下溢、溢出，并有舍入误差。浮点数用一个邻近的数字代替数学上正确的答案。有一种更好的方法来做浮点运算。它被称为 unum，这是一个更容易使用、更准确、对内存和能源要求更低、比 IEEE 标准浮点数更快的通用数字。

### 错误的终结

![error](../Images/262fc33b85777919da6b3dbc59880fd1.png) *错误的终结:Unum 计算*作者【约翰·l·古斯塔夫森】用一个只用五位表示的简单整数系统开始了他的浮点运算超集的案例。数字 11111 代表+16，数字 01111 代表零，00000 代表-15。10001(+一)和 10010(+二)相加等于 10011(+三)。这是简单的二进制算术。

10111(+七)和 11010(+十)加在一起会怎么样？答案，显然是十七。这在五位数格式中是如何表示的？如果在任何计算机中实现这种数据类型，答案将溢出，答案将是 00000(-15)，尽管答案是错误的，但在答案泄露到现实世界之前，不会发生任何有意义的事情。

IEEE floats 有异常和测试，但是作为 float 计算的结果并不总是精确的结果。这就是浮点运算的问题；给出精确结果的问题太难了，所以用不精确的结果来代替。

[Gustafson]对这个问题的解决方案是 IEEE floats 的*超集*。

IEEE 浮点数只有三部分——符号、指数和分数。而 32 位浮点数能够表示 10^-38 和 10^38 之间的数字，精度约为七位小数。
![single-precision](../Images/d6d2a033cafb99db0205a259fe0661b1.png)

另一方面，Unums 是 IEEE 浮点数的超集。它们包括三个额外的元数据:ubit、指数的大小和分数的大小。

![unum-format](../Images/dfa1d6b9afb0656b24e857fea999968c.png)

### 单位

[古斯塔夫森]给出的 ubit 效用的例子只是一个问题:π的值是多少？它是 3.141592653，这对于任何计算都足够好了。圆周率继续，我们在圆周率的末尾加了一个省略号，表示“3.141592653…”那么，7/2 的值是多少？那就是“3.5”——结尾没有省略号。出于某种原因，人类已经有能力指定一个数字是连续的，或者它是否精确了几百年，而计算机还没有赶上。ubit 是这个问题的解决方案，它只是一个比特，表示分数是否精确，或者分数中是否有更多的非零比特。

### 指数大小和分数大小

[Gustafson]添加到浮点数格式的两个额外的元数据是指数的大小和分数的大小。这两者分别是存储指数或分数中最大位数所需的位数。例如，如果分数的值是 110101011，则分数大小是 9 位，在二进制中是 1001。因此，分数大小为 4 位长，这是表示分数大小为 9 所需的位数。

通过仅存储指数和分数中需要的内容，每个 unum 的平均大小减小了，即使在最坏的情况下，unum 大于四倍精度浮点。精度得以保持，甚至可以表示比四象限所能处理的更大的数字。

![The loss of the first Ariane V rocket.](../Images/52d596a5b0633e14b572f83114c89749.png)

The loss of the first Ariane V rocket.

如果处理改变数据结构长度的数字听起来很可笑，那么可以这样想:我们已经处理了至少四种不同的浮点大小，两者之间的转换可能会带来灾难性的后果。

在阿丽亚娜 5 号火箭的第一次发射中，工程师们重复使用了早期阿丽亚娜 4 号的惯性平台。阿丽亚娜 5 号是一个更大、更快的火箭，更高的加速度导致数据从 64 位浮点到 16 位整数的转换溢出。一个 unum 会阻止这一切。

unums 有相当多的缺点；从 Zuse Z1 开始，一直到 80 年代的第一个数学协处理器，甚至到今天，芯片设计人员已经将浮点单元放在硅片中。无论好坏，你的计算机处理浮点运算的能力是绰绰有余的。

在技术上，我们处于局部最小值。对于表示数字，Unums 是比 floats 更好的选择，但是这是有代价的。任何 unums 的实现最终都依赖于软件，而不是 IEEE 浮点引入后 30 年的芯片设计。它可能永远不会在商业硬件中实现，但它将会解决很多问题。